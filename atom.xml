<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep</title>
  
  <subtitle>Hexo theme keep quick starter</subtitle>
  <link href="https://zhaozhan.site/atom.xml" rel="self"/>
  
  <link href="https://zhaozhan.site/"/>
  <updated>2024-03-20T11:49:34.000Z</updated>
  <id>https://zhaozhan.site/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx入门</title>
    <link href="https://zhaozhan.site/2024/03/20/Nginx%E5%85%A5%E9%97%A8/"/>
    <id>https://zhaozhan.site/2024/03/20/Nginx%E5%85%A5%E9%97%A8/</id>
    <published>2024-03-20T04:56:56.000Z</published>
    <updated>2024-03-20T11:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h1><p><strong>Nginx (engine x)</strong> 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/image.1sesudl89z.webp"                        alt="image"                 ></p><p>而正向代理就是我们在客户端平时使用的代理。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>当请求量非常大时，可以将请求分发到各个服务器上。</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/image.1lbkyy08b2.webp"                        alt="image"                 ></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>什么是动静分离：其实就是将一些静态的、不会变的资源通过nginx直接拿去，而不需要去请求后台，避免后端压力过大</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/image.7smyz438l9.webp"                        alt="image"                 ></p><h1 id="Nginx入门"><a href="#Nginx入门" class="headerlink" title="Nginx入门"></a>Nginx入门</h1><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>Nginx的配置文件在Linux中位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>nginx 的使用比较简单，就是几条命令。</p><p>常用到的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure><h1 id="Nginx实战"><a href="#Nginx实战" class="headerlink" title="Nginx实战"></a>Nginx实战</h1><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/image.syphgzhgj.webp"                        alt="image"                 ></p><p>上图，在浏览器中输入localhost：80会重定向到localhost：3000，但是会隐藏localhost：3000这一地址。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a class="link"   href="https://zhuanlan.zhihu.com/p/382228615" >知乎：Nginx的简介和安装<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/weixin_54065960/article/details/131455673" >CSDN：Nginx入门教程<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx概述&quot;&gt;&lt;a href=&quot;#Nginx概述&quot; class=&quot;headerlink&quot; title=&quot;Nginx概述&quot;&gt;&lt;/a&gt;Nginx概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Nginx (engine x)&lt;/strong&gt; 是一款轻量级的 Web 服务器 </summary>
      
    
    
    
    <category term="linux" scheme="https://zhaozhan.site/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zhaozhan.site/tags/linux/"/>
    
    <category term="nginx" scheme="https://zhaozhan.site/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ssh详解</title>
    <link href="https://zhaozhan.site/2024/03/02/ssh%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhaozhan.site/2024/03/02/ssh%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-03-02T06:47:54.000Z</published>
    <updated>2024-03-19T12:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><p><strong>Secure Shell</strong> (<strong>SSH</strong>) 是一个允许两台电脑之间通过安全的连接进行数据交换 的<strong>网络协议</strong>。</p><ul><li><p>传统：FTP、Telnet 是再网络中明文传送数据、用户帐号和密码，很容易受到中间人攻击 。</p></li><li><p>SSH：利用 SSH 协议 可以有效防止远程管理过程中的信息泄露问题。通过<strong>SSH</strong>可以对所有传输的数据进行加 密，也能够防止 DNS 欺骗和 IP 欺骗。</p></li></ul><blockquote><p>补充：SSH使用的是非对称加密的一种：使用公钥和私钥进行加密和解密，一般使用公钥加密，私钥解密。</p></blockquote><p>SSH的<strong>身份验证阶段，SSH只支持服务端保留公钥，客户端保留私钥的方式，</strong>所以方式只有两种：客户端生成密钥对，将公钥分发给服务端；服务端生成密钥对，将私钥分发给客户端。只不过出于安全性和便利性，一般都是客户端生成密钥对并分发公钥。</p><h1 id="SSH概要"><a href="#SSH概要" class="headerlink" title="SSH概要"></a>SSH概要</h1><ul><li><p>SSH是会话层上的协议</p></li><li><p>SSH服务的守护进程是sshd,默认监听在22端口</p></li><li><p>SSH客户端命令读取两个配置文件,也可以在输入命令时配置。</p><ul><li>全局：&#x2F;etc&#x2F;ssh&#x2F;ssh_config</li><li>用户：~&#x2F;.ssh&#x2F;config</li><li>优先级：命令配置&gt;用户&gt;全局</li></ul></li><li><p>SSH涉及到两个验证：主机验证、用户验证</p></li><li><p>SSH支持多种身份验证，<strong>它们的验证顺序如下：gssapi-with-mic,hostbased,publickey,keyboard-interactive,password</strong>，但常见的是密码认证机制(password)和公钥认证机制(public key)。</p></li><li><p>SSH客户端有很多强大的功能：端口转发、代理认证、连接共享等</p></li><li><p>SSH服务端配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config（与客户端配置文件区分开）</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.2vei3thblf.webp"                        alt="图片"                 ></p></li><li><p>易被忽略：SSH登陆会被分配一个伪终端，可以配置sudo这种身份验证程序被禁止使用</p></li></ul><h1 id="主机验证过程"><a href="#主机验证过程" class="headerlink" title="主机验证过程"></a>主机验证过程</h1><p>客户端输入以下命令之后，首先进行主机验证过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh ip_addr</span><br></pre></td></tr></table></figure><ul><li><p>客户端首先读取~&#x2F;.ssh&#x2F;known_hosts文件和&#x2F;etc&#x2F;ssh&#x2F;known_hosts文件，看其中是否存储了服务端的主机信息（host key），如果没有，询问是否保存该服务端的主机信息；如果有，直接进入身份验证</p></li><li><p>服务端的host key在&#x2F;etc&#x2F;ssh&#x2F;ssh_host_*.pub文件中（不同加密算法不同，在sshd服务程序启动时重建）</p><p>主机验证阶段：<strong>服务端持有的是私钥，客户端保存的是服务端的公钥，这和身份验证阶段密钥持有方相反</strong></p></li></ul><blockquote><p>补充：实际上ssh对比的不是host key,因为太长了，对比的是host key的指纹。指纹可以通过ssh-kegen计算得出。ssh还支持host key的模糊比较（图形对比）。</p></blockquote><p>更详细的主机认证过程是：先进行密钥交换(DH算法)生成session key(rfc文档中称之为shared secret)，然后从文件中读取host key，并用host key对session key进行签名，然后对签名后的指纹进行判断。</p><h1 id="身份认证过程"><a href="#身份认证过程" class="headerlink" title="身份认证过程"></a>身份认证过程</h1><p>常见的身份认证为密码认证和公钥认证，当公钥认证机制未通过时，再进行密码认证机制。认证顺序可以通过ssh配置文件中的指令PerferredAuthentications改变。</p><ul><li>公钥认证：客户端需将自己生成的公钥（<del>&#x2F;.ssh&#x2F;id_*.pub）发送到服务端的</del>&#x2F;.ssh&#x2F;authorized_keys文件中。认证时将私钥推导或者公钥指纹（不同版本）发给服务端。服务端判断是否认证通过，如果认证不通过，则进入下一个认证机制：密码认证机制。</li><li>密码认证：输入服务端用户密码。</li></ul><h1 id="配置文件分布"><a href="#配置文件分布" class="headerlink" title="配置文件分布"></a>配置文件分布</h1><p>服务端：</p><ul><li>&#x2F;etc&#x2F;ssh&#x2F;sshd_config：ssh服务程序sshd的配置文件。</li><li>&#x2F;etc&#x2F;ssh&#x2F;ssh_host_*：服务程序sshd启动时生成的服务端公钥和私钥文件。如ssh_host_rsa_key和ssh_host_rsa_key.pub。<ul><li>其中.pub文件是主机验证时的host key，将写入到客户端的~&#x2F;.ssh&#x2F;known_hosts文件中。</li><li><strong>其中私钥文件严格要求权限为600，若不是则sshd服务可能会拒绝启动。</strong></li></ul></li><li>~&#x2F;.ssh&#x2F;authorized_keys：保存的是基于公钥认证机制时来自于客户端的公钥。在基于公钥认证机制认证时，服务端将读取该文件。</li></ul><p>客户端：</p><ul><li>&#x2F;etc&#x2F;ssh&#x2F;ssh_config：客户端的全局配置文件。</li><li>~&#x2F;.ssh&#x2F;config：客户端的用户配置文件，生效优先级高于全局配置文件。一般该文件默认不存在。该文件对权限有严格要求只对所有者有读&#x2F;写权限，对其他人完全拒绝写权限。</li><li>~&#x2F;.ssh&#x2F;known_hosts：保存主机验证时服务端主机host key的文件。文件内容来源于服务端的ssh_host_rsa_key.pub文件。</li><li>&#x2F;etc&#x2F;ssh&#x2F;known_hosts：全局host key保存文件。作用等同于~&#x2F;.ssh&#x2F;known_hosts。</li><li>~&#x2F;.ssh&#x2F;id_rsa：客户端生成的私钥。由ssh-keygen生成。<strong>该文件严格要求权限，当其他用户对此文件有可读权限时，ssh将直接忽略该文件。</strong></li><li><del>&#x2F;.ssh&#x2F;id_rsa.pub    ：私钥id_rsa的配对公钥。对权限不敏感。当采用公钥认证机制时，该文件内容需要复制到服务端的</del>&#x2F;.ssh&#x2F;authorized_keys文件中。</li><li>~&#x2F;.ssh&#x2F;rc：保存的是命令列表，这些命令在ssh连接到远程主机成功时将第一时间执行，执行完这些命令之后才开始登陆或执行ssh命令行中的命令。</li><li>&#x2F;etc&#x2F;ssh&#x2F;rc：作用等同于~&#x2F;.ssh&#x2F;rc。</li></ul><p>简单介绍sshd_config指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Port 22                <span class="comment"># 服务端SSH端口，可以指定多条表示监听在多个端口上</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ListenAddress 0.0.0.0  <span class="comment"># 监听的IP地址。0.0.0.0表示监听所有IP</span></span></span><br><span class="line">Protocol 2              # 使用SSH 2版本</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">         私钥保存位置               <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HostKey <span class="keyword">for</span> protocol version 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HostKey /etc/ssh/ssh_host_key      <span class="comment"># SSH 1保存位置/etc/ssh/ssh_host_key</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HostKeys <span class="keyword">for</span> protocol version 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HostKey /etc/ssh/ssh_host_rsa_key  <span class="comment"># SSH 2保存RSA位置/etc/ssh/ssh_host_rsa _key</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HostKey /etc/ssh/ssh_host_dsa_key  <span class="comment"># SSH 2保存DSA位置/etc/ssh/ssh_host_dsa _key</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">          杂项配置               <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PidFile /var/run/sshd.pid        <span class="comment"># 服务程序sshd的PID的文件路径</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ServerKeyBits 1024               <span class="comment"># 服务器生成的密钥长度</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SyslogFacility AUTH              <span class="comment"># 使用哪个syslog设施记录ssh日志。日志路径默认为/var/log/secure</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">LogLevel INFO                    <span class="comment"># 记录SSH的日志级别为INFO</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  以下项影响认证速度               <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">UseDNS <span class="built_in">yes</span>                       <span class="comment"># 指定是否将客户端主机名解析为IP，以检查此主机名是否与其IP地址真实对应。默认yes。</span></span></span><br><span class="line">                                  # 由此可知该项影响的是主机验证阶段。建议在未配置DNS解析时，将其设置为no，否则主机验证阶段会很慢</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  以下是和安全有关的配置           <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PermitRootLogin <span class="built_in">yes</span>              <span class="comment"># 是否允许root用户登录</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GSSAPIAuthentication no          <span class="comment"># 是否开启GSSAPI身份认证机制，默认为yes</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PubkeyAuthentication <span class="built_in">yes</span>         <span class="comment"># 是否开启基于公钥认证机制</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">AuthorizedKeysFile  .ssh/authorized_keys  <span class="comment"># 基于公钥认证机制时，来自客户端的公钥的存放位置</span></span></span><br><span class="line">PasswordAuthentication yes        # 是否使用密码验证，如果使用密钥对验证可以关了它</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PermitEmptyPasswords no          <span class="comment"># 是否允许空密码，如果上面的那项是yes，这里最好设置no</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MaxSessions 10                   <span class="comment"># 最大客户端连接数量</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">LoginGraceTime 2m                <span class="comment"># 身份验证阶段的超时时间，若在此超时期间内未完成身份验证将自动断开</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MaxAuthTries 6                   <span class="comment"># 指定每个连接最大允许的认证次数。默认值是6。</span></span></span><br><span class="line">                                  # 如果失败认证次数超过该值一半，将被强制断开，且生成额外日志消息。</span><br><span class="line">MaxStartups 10                    # 最大允许保持多少个未认证的连接。默认值10。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  以下可以自行添加到配置文件        <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line">DenyGroups  hellogroup testgroup  # 表示hellogroup和testgroup组中的成员不允许使用sshd服务，即拒绝这些用户连接</span><br><span class="line">DenyUsers   hello test            # 表示用户hello和test不能使用sshd服务，即拒绝这些用户连接</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  以下一项和远程端口转发有关        <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GatewayPorts no                  <span class="comment"># 设置为yes表示sshd允许被远程主机所设置的本地转发端口绑定在非环回地址上</span></span></span><br><span class="line">                                  # 默认值为no，表示远程主机设置的本地转发端口只能绑定在环回地址上，见后文&quot;远程端口转发&quot;</span><br></pre></td></tr></table></figure><p>关于&#x2F;etc&#x2F;ssh&#x2F;sshd_config的更多配置选项参考<a class="link"   href="http://www.jinbuguo.com/openssh/sshd_config.html" >sshd_config中文文档<i class="fas fa-external-link-alt"></i></a></p><p>简单介绍ssh_config文件相关指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Host *                              <span class="comment"># Host指令是ssh_config中最重要的指令，只有ssh连接的目标主机名能匹配此处给定模式时，</span></span></span><br><span class="line">                                      # 下面一系列配置项直到出现下一个Host指令才对此次连接生效</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  ForwardAgent no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  ForwardX11 no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  RhostsRSAAuthentication no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  RSAAuthentication <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  PasswordAuthentication <span class="built_in">yes</span>     <span class="comment"># 是否启用基于密码的身份认证机制</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  HostbasedAuthentication no     <span class="comment"># 是否启用基于主机的身份认证机制</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  GSSAPIAuthentication no        <span class="comment"># 是否启用基于GSSAPI的身份认证机制</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  GSSAPIDelegateCredentials no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  GSSAPIKeyExchange no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  GSSAPITrustDNS no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  BatchMode no                   <span class="comment"># 如果设置为&quot;yes&quot;，将禁止passphrase/password询问。比较适用于在那些不需要询问提供密</span></span></span><br><span class="line">                                   # 码的脚本或批处理任务任务中。默认为&quot;no&quot;。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  CheckHostIP <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  AddressFamily any</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  ConnectTimeout 0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  StrictHostKeyChecking ask        <span class="comment"># 设置为&quot;yes&quot;，ssh将从不自动添加host key到~/.ssh/known_hosts文件，</span></span></span><br><span class="line">                                     # 且拒绝连接那些未知的主机(即未保存host key的主机或host key已改变的主机)。</span><br><span class="line">                                     # 它将强制用户手动添加host key到~/.ssh/known_hosts中。</span><br><span class="line">                                     # 设置为ask将询问是否保存到~/.ssh/known_hosts文件。</span><br><span class="line">                                     # 设置为no将自动添加到~/.ssh/known_hosts文件。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  IdentityFile ~/.ssh/identity     <span class="comment"># ssh v1版使用的私钥文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  IdentityFile ~/.ssh/id_rsa       <span class="comment"># ssh v2使用的rsa算法的私钥文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  IdentityFile ~/.ssh/id_dsa       <span class="comment"># ssh v2使用的dsa算法的私钥文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Port 22                          <span class="comment"># 当命令行中不指定端口时，默认连接的远程主机上的端口</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Protocol 2,1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Cipher 3des                      <span class="comment"># 指定ssh v1版本中加密会话时使用的加密协议</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc  <span class="comment"># 指定ssh v1版本中加密会话时使用的加密协议</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  EscapeChar ~</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Tunnel no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  TunnelDevice any:any</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  PermitLocalCommand no    <span class="comment"># 功能等价于~/.ssh/rc，表示是否允许ssh连接成功后在本地执行LocalCommand指令指定的命令。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  LocalCommand             <span class="comment"># 指定连接成功后要在本地执行的命令列表，当PermitLocalCommand设置为no时将自动忽略该配置</span></span></span><br><span class="line">                             # %d表本地用户家目录，%h表示远程主机名，%l表示本地主机名，%n表示命令行上提供的主机名，</span><br><span class="line">                             # p%表示远程ssh端口，r%表示远程用户名，u%表示本地用户名。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  VisualHostKey no         <span class="comment"># 是否开启主机验证阶段时host key的图形化指纹</span></span></span><br><span class="line">Host *</span><br><span class="line">        GSSAPIAuthentication yes</span><br></pre></td></tr></table></figure><p>关于上述配置文件的相关内容参考<a class="link"   href="https://www.cnblogs.com/f-ck-need-u/p/7129122.html" >相关链接<i class="fas fa-external-link-alt"></i></a></p><h1 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ssh [options] [user@]hostname [command]</span><br><span class="line"> </span><br><span class="line">参数说明：</span><br><span class="line">-b bind_address ：在本地主机上绑定用于ssh连接的地址，当系统有多个ip时才生效。</span><br><span class="line">-E log_file     ：将debug日志写入到log_file中，而不是默认的标准错误输出stderr。</span><br><span class="line">-F configfile   ：指定用户配置文件，默认为~/.ssh/config。</span><br><span class="line">-f              ：请求ssh在工作在后台模式。该选项隐含了&quot;-n&quot;选项，所以标准输入将变为/dev/null。</span><br><span class="line">-i identity_file：指定公钥认证时要读取的私钥文件。默认为~/.ssh/id_rsa。</span><br><span class="line">-l login_name   ：指定登录在远程机器上的用户名。也可以在全局配置文件中设置。</span><br><span class="line">-N              ：显式指明ssh不执行远程命令。一般用于端口转发，见后文端口转发的示例分析。</span><br><span class="line">-n              ：将/dev/null作为标准输入stdin，可以防止从标准输入中读取内容。ssh在后台运行时默认该项。</span><br><span class="line">-p port         ：指定要连接远程主机上哪个端口，也可在全局配置文件中指定默认的连接端口。</span><br><span class="line">-q              ：静默模式。大多数警告信息将不输出。</span><br><span class="line">-T              ：禁止为ssh分配伪终端。</span><br><span class="line">-t              ：强制分配伪终端，重复使用该选项&quot;-tt&quot;将进一步强制。</span><br><span class="line">-v              ：详细模式，将输出debug消息，可用于调试。&quot;-vvv&quot;可更详细。</span><br><span class="line">-V              ：显示版本号并退出。</span><br><span class="line">-o              ：指定额外选项，选项非常多。</span><br><span class="line">user@hostname   ：指定ssh以远程主机hostname上的用户user连接到的远程主机上，若省略user部分，则表示使用本地当前用户。</span><br><span class="line">                ：如果在hostname上不存在user用户，则连接将失败(将不断进行身份验证)。</span><br><span class="line">command         ：要在远程主机上执行的命令。指定该参数时，ssh的行为将不再是登录，而是执行命令，命令执行完毕时ssh连接就关闭。</span><br></pre></td></tr></table></figure><p>如果要ssh免密登陆可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">id_ed25519.pub改为自己的算法对应的文件名，ip_addr改为自己的服务端ip</span></span><br><span class="line">cat ~/.ssh/id_ed25519.pub | ssh ip_addr &quot;umask 077; test -d ~/.ssh || mkdir ~/.ssh ; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span><br></pre></td></tr></table></figure><p>或者直接使用提供好的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该命令可以直接将公钥分发给服务端，具体实现逻辑和上述命令相同</span></span><br><span class="line">ssh-copy-id ip_addr</span><br></pre></td></tr></table></figure><h1 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h1><p>scp是基于ssh的远程拷贝命令，也支持本地拷贝，甚至支持远程到远程的拷贝。<strong>scp拷贝是使用的22端口，其实质是使用ssh连接到远程，并使用该连接来传输数据</strong>。</p><p>具体使用方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scp [-12BCpqrv] [-l limit] [-o ssh_option] [-P port] [[user@]host1:]src_file ... [[user@]host2:]dest_file</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line">-1：使用ssh v1版本，这是默认使用协议版本</span><br><span class="line">-2：使用ssh v2版本</span><br><span class="line">-C：拷贝时先压缩，节省带宽</span><br><span class="line">-l limit：限制拷贝速度，Kbit/s，1Byte=8bit，所以&quot;-l 800&quot;表示的速率是100K/S</span><br><span class="line">-o ssh_option：指定ssh连接时的特殊选项，一般用不上。</span><br><span class="line">-P port：指定目标主机上ssh端口，大写的字母P，默认是22端口</span><br><span class="line">-p：拷贝时保持源文件的mtime,atime,owner,group,privileges</span><br><span class="line">-r：递归拷贝，用于拷贝目录。注意，scp拷贝遇到链接文件时，会拷贝链接的源文件内容填充到目标文件中(scp的本质就是填充而非拷贝)</span><br><span class="line">-v：输出详细信息，可以用来调试或查看scp的详细过程，分析scp的机制</span><br></pre></td></tr></table></figure><p><strong>(1).本地拷贝到本地：&#x2F;etc&#x2F;fstab–&gt;&#x2F;tmp&#x2F;a.txt。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /etc/fstab /tmp/a.txt</span><br></pre></td></tr></table></figure><p><strong>(2).本地到远程：&#x2F;etc&#x2F;fstab–&gt;ip_addr:&#x2F;tmp&#x2F;a.txt。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /etc/fstab ip_addr:/tmp</span><br></pre></td></tr></table></figure><p><strong>(3).远程到本地：ip_addr:&#x2F;etc&#x2F;fstab–&gt;&#x2F;tmp&#x2F;a.txt。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ip_addr:/etc/fstab /tmp/a.txt</span><br></pre></td></tr></table></figure><p><strong>(4).远程ip_addr1到远程ip_addr2：ip_addr1:&#x2F;etc&#x2F;fstab–&gt;&#x2F;ip_addr2:&#x2F;tmp&#x2F;a.txt。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ip_addr1:/etc/fstab ip_addr2:/tmp/a.txt</span><br></pre></td></tr></table></figure><h1 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h1><p><strong>ssh-keygen 命令</strong>用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认 证密钥。</p><p>该命令的选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用的选项</span></span><br><span class="line">-b：指定密钥长度； </span><br><span class="line">-C：添加注释；用于为指定注释，可以是任何内容，通常使用自己的邮件名作为注释。 </span><br><span class="line">-f：指定用来保存密钥的文件名； </span><br><span class="line">-t：指定要创建的密钥类型（加密方式）; </span><br><span class="line">-e：读取openssh的私钥或者公钥文件； </span><br><span class="line">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； </span><br><span class="line">-l：显示公钥文件的指纹数据； </span><br><span class="line">-N：提供一个新密语； </span><br><span class="line">-P：提供（旧）密语； </span><br><span class="line">-q：静默模式； </span><br></pre></td></tr></table></figure><p>生成密钥对时，有一个选项要求你设置密码（passphrase），该密码是用来保护你的私钥的 密码。如果设置了则在使用私钥时会要求你输入这个密码；<strong>一般不设置，记不住</strong>【之后 还可更改此密码，使用<code>ssh-keygen -p</code>】。</p><p>生成后最好将私钥进行备份。</p><p><strong>常用的两种加密方式：</strong></p><ul><li>为了安全考虑如果使用 rsa 加密方式则指定密钥长度为 <code>-b 4096</code>（1024 的密钥长度能够被破解，建议指定为 4096）。</li><li>但现在有了更安全的加密方式 ed25519 ，这是目前最受推荐的公钥算法。当使用 ed25519 加密方式时，它会忽略 <code>-b</code> 选项，因为它的长度是固定的。生成的密钥更紧凑 、更短（仅包含 68 个字符）、在签名验证时也更快并且还更安全。它还将使用新的 OpenSSH 格式（OpenSSH 6.5+）而不是 PEM 格式保存私钥，Windows10 中的 OpenSSH 最先支持的也是 ed25519 类型的密钥。</li></ul><p><strong>使用 rsa 加密方式的示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;注释&quot;</span> -b 4096</span> </span><br><span class="line">Generating public/private rsa key pair. </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定密钥文件名称；直接回车则使用默认名称 id_rsa</span> </span><br><span class="line">Enter file in which to save the key (/home/xxx/.ssh/id_rsa):</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入密码(一般不输入密码，直接回车)</span> </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次输入密码</span> </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /home/fan/.ssh/FDGitHub_rsa. </span><br><span class="line">Your public key has been saved in /home/xxx/.ssh/id_rsa.pub. The key fingerprint is: </span><br><span class="line">***********************</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在其他地方导入公钥时一定要将公钥文件中的 *全部内容* 都导入，包括末尾你的邮箱。</span> </span><br></pre></td></tr></table></figure><p><strong>使用 ed25519 加密方式生成密钥的示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;注释&quot; # 默认的密钥文件中将带有ed25519，比如： ~/.ssh/id_ed25519 ~/.ssh/id_ed25519.pub </span><br></pre></td></tr></table></figure><p><strong>公钥</strong>是一串很长的字符；为了便于肉眼比对和识别，所以有了指纹这东西；指纹位数短 ，更便于识别且与公钥一一对应。</p><p>公钥加密指纹 fingerprint 有两种形式：</p><ul><li>之前的十六进制形式：<code>16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48</code></li><li>现在使用 sha256 哈希值并且使用 base64 进行格式 ：<code>SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8</code></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a class="link"   href="https://junmajinlong.com/linux/ssh/" >ssh和ssh服务<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是SSH&quot;&gt;&lt;a href=&quot;#什么是SSH&quot; class=&quot;headerlink&quot; title=&quot;什么是SSH&quot;&gt;&lt;/a&gt;什么是SSH&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Secure Shell&lt;/strong&gt; (&lt;strong&gt;SSH&lt;/strong&gt;) 是</summary>
      
    
    
    
    <category term="linux" scheme="https://zhaozhan.site/categories/linux/"/>
    
    
    <category term="ssh" scheme="https://zhaozhan.site/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>ArchLinux安装</title>
    <link href="https://zhaozhan.site/2024/02/19/ArchLinux%E5%AE%89%E8%A3%85/"/>
    <id>https://zhaozhan.site/2024/02/19/ArchLinux%E5%AE%89%E8%A3%85/</id>
    <published>2024-02-19T10:19:34.000Z</published>
    <updated>2024-02-20T14:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启动U盘"><a href="#启动U盘" class="headerlink" title="启动U盘"></a>启动U盘</h1><p><a class="link"   href="https://archlinux.org/download/" >下载镜像<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.ventoy.net/cn/doc_start.html" >Ventoy烧录<i class="fas fa-external-link-alt"></i></a></p><p>进入BIOS中关闭Secure Boot</p><p>调整启动方式为UEFI（对应磁盘格式为GPT，之后格式化的时候会改）</p><p>使用U盘启动</p><p>进入如下archlinux的live页面</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.2ob94sb57l.webp"                        alt="图片"                 ></p><h1 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h1><ol><li><h2 id="进入-Live-环境后关闭-reflector："><a href="#进入-Live-环境后关闭-reflector：" class="headerlink" title="进入 Live 环境后关闭 reflector："></a>进入 Live 环境后关闭 reflector：</h2></li></ol><p><code>systemctl stop reflector</code></p><p>reflector 会根据速度自动修改镜像源，但是由于只考虑最新的20个镜像站，其结果大多数时候都不怎么好用。</p><ol start="2"><li><h2 id="确保使用的UEFI模式："><a href="#确保使用的UEFI模式：" class="headerlink" title="确保使用的UEFI模式："></a>确保使用的UEFI模式：</h2></li></ol><p><code>ls /sys/firmware/efi/efivars</code></p><p>若有效输出则已启动</p><ol start="3"><li><h2 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h2></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iwctl                           <span class="comment">#执行iwctl命令，进入交互式命令行</span></span><br><span class="line">device list                     <span class="comment">#列出设备名，比如无线网卡看到叫 wlan0</span></span><br><span class="line">station wlan0 scan              <span class="comment">#扫描网络</span></span><br><span class="line">station wlan0 get-networks      <span class="comment">#列出网络 比如想连接YOUR-WIRELESS-NAME这个无线</span></span><br><span class="line">station wlan0 connect YOUR-WIRELESS-NAME <span class="comment">#进行连接 输入密码即可exit  </span></span><br></pre></td></tr></table></figure><p>可以等待几秒等网络建立连接后再进行下面测试网络的操作。</p><p><code>ping ``www.gnu.org</code></p><p>如果你不能正常连接网络，首先确认系统已经启用网络接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span>  <span class="comment">#列出网络接口信息，如无线联网的设备叫wlan0</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> wlan0 up <span class="comment">#比如无线网卡看到叫 wlan0</span></span><br></pre></td></tr></table></figure><p>如果随后看到类似 <code>Operation not possible due to RF-kill</code>的报错，继续尝试 <code>rfkill</code>命令来解锁无线网卡：<code>rfkill unblock wifi</code></p><ol start="4"><li><h2 id="更新系统时钟"><a href="#更新系统时钟" class="headerlink" title="更新系统时钟"></a>更新系统时钟</h2></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp <span class="literal">true</span>    <span class="comment">#将系统时间与网络时间进行同步</span></span><br><span class="line">timedatectl status          <span class="comment">#检查服务状态</span></span><br></pre></td></tr></table></figure><ol start="5"><li><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2></li></ol><p>一个通用的方案：</p><table><thead><tr><th>挂载点</th><th>分区</th><th>分区类型</th><th>建议大小</th><th>备注</th></tr></thead><tbody><tr><td>&#x2F;mnt&#x2F;boot</td><td>&#x2F;dev&#x2F;sda1 或&#x2F;dev&#x2F;nvme0n1p1</td><td>EFI System</td><td>512 MiB</td><td>ESP 分区</td></tr><tr><td>&#x2F;mnt</td><td>&#x2F;dev&#x2F;sda2 或&#x2F;dev&#x2F;nvme0n1p2</td><td>Linux x86-64 root</td><td>100 GiB（至少 50 GiB）</td><td>Arch Linux 的根分区</td></tr><tr><td>&#x2F;mnt&#x2F;home</td><td>&#x2F;dev&#x2F;sda3 或&#x2F;dev&#x2F;nvme0n1p3</td><td>Linux home</td><td>剩余磁盘空间</td><td>Arch Linux 的 home 分区</td></tr></tbody></table><p>首先将磁盘类型转换为GPT格式，这里假设比如你想安装的磁盘名称为 sdx。如果你使用 NVME 的固态硬盘，你看到的磁盘名称可能为 nvme0n1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsblk                       <span class="comment">#显示分区情况 找到你想安装的磁盘名称</span></span><br><span class="line">parted /dev/sdx             <span class="comment">#执行parted，进入交互式命令行，进行磁盘类型变更</span></span><br><span class="line">(parted)mktable             <span class="comment">#输入mktable</span></span><br><span class="line">New disk label <span class="built_in">type</span>? gpt    <span class="comment">#输入gpt 将磁盘类型转换为gpt 如磁盘有数据会警告，输入yes即可</span></span><br><span class="line">quit                        <span class="comment">#最后quit退出parted命令行交互</span></span><br></pre></td></tr></table></figure><p>然后进行分区操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sdx <span class="comment">#来执行分区操作,分配各个分区大小，类型</span></span><br><span class="line">fdisk -l <span class="comment">#分区结束后， 复查磁盘情况</span></span><br></pre></td></tr></table></figure><p>其次是格式化操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4  /dev/sdax            <span class="comment">#格式化根目录和home目录的两个分区</span></span><br><span class="line">mkfs.vfat  /dev/sdax            <span class="comment">#格式化efi分区</span></span><br></pre></td></tr></table></figure><p>最后是挂载操作</p><p>在挂载时，挂载是有顺序的，先挂载根分区，再挂载 EFI 分区。 这里的 sdax 只是例子，具体根据你自身的实际分区情况来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdax  /mnt</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/efi     <span class="comment">#创建efi目录</span></span><br><span class="line">mount /dev/sdax /mnt/efi</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/home    <span class="comment">#创建home目录</span></span><br><span class="line">mount /dev/sdax /mnt/home</span><br></pre></td></tr></table></figure><ol start="6"><li><h2 id="建立交换文件（可选）"><a href="#建立交换文件（可选）" class="headerlink" title="建立交换文件（可选）"></a>建立交换文件（可选）</h2></li></ol><p>交换文件相当于 Windows 中的虚拟内存，也就是利用硬盘空间充当内存。当内存<strong>相对</strong>不足时，部分内存中的内容会交换到硬盘中，从而释放内存。关于 swap 的重要性，有两篇不错的文章，推荐读者阅读。</p><p><a class="link"   href="https://farseerfc.me/zhs/in-defence-of-swap.html" >https://farseerfc.me/zhs/in-defence-of-swap.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://farseerfc.me/zhs/followup-about-swap.html" >https://farseerfc.me/zhs/followup-about-swap.html<i class="fas fa-external-link-alt"></i></a></p><p>推荐swap大小</p><table><thead><tr><th>内存大小</th><th>2 GiB</th><th>4 GiB</th><th>8 GiB</th><th>16 GiB</th><th>32 GiB</th><th>64 GiB</th></tr></thead><tbody><tr><td>推荐的交换文件大小（使用休眠功能）</td><td>4096 MiB</td><td>5793 MiB</td><td>8192 MiB</td><td>11585 MiB</td><td>16384 MiB</td><td>23170 MiB</td></tr><tr><td>推荐的交换文件大小（不使用休眠功能）</td><td>4096 MiB</td><td>5793 MiB</td><td>8192 MiB</td><td>8192 MiB</td><td>4096 MiB</td><td>0 MiB</td></tr></tbody></table><p>建立交换文件的具体操作方法如下。</p><p>首先使用 dd 创建交换文件。例如，创建一块 8 GiB （&#x3D;8192 MiB）大小的交换文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/mnt/swapfile bs=1M count=8192 status=progress</span><br></pre></td></tr></table></figure><p>如果您需要创建其他大小的交换文件，请将 count&#x3D; 后面的数值换成交换文件大小的 MiB 数（GiB 数 x 1024）。</p><p>然后修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 0600 /mnt/swapfile</span><br></pre></td></tr></table></figure><p>最后格式化并启用swap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap -U clear /mnt/swapfile</span><br><span class="line">swapon /mnt/swapfile</span><br></pre></td></tr></table></figure><ol start="7"><li><h2 id="选择软件仓库镜像"><a href="#选择软件仓库镜像" class="headerlink" title="选择软件仓库镜像"></a>选择软件仓库镜像</h2></li><li><h3 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h3></li></ol><p>推荐使用reflector，使用如下命令选择镜像。此命令将为您选出位于平均同步延迟在 3 小时以内的，位于中国的 https 镜像，并根据速度排序。指定 –completion-percent 95（默认为100）的目的是防止忽略可用的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflector -p https -c China --delay 3 --completion-percent 95 --<span class="built_in">sort</span> rate --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>也可使用得分排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflector -p https -c China --delay 3 --completion-percent 95 --<span class="built_in">sort</span> score --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><ol start="2"><li><h3 id="手动自行修改"><a href="#手动自行修改" class="headerlink" title="手动自行修改"></a>手动自行修改</h3></li></ol><p>也可以手动修改 <code>/etc/pacman.d/mirrorlist</code>配置文件，使用vim或nano在 <code>/etc/pacman.d/mirrorlist</code>中添加镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ <span class="comment"># nano /etc/pacman.d/mirrorlist</span></span><br><span class="line"></span><br><span class="line">/etc/pacman.d/mirrorlist</span><br><span class="line">------------------------</span><br><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><p>默认先使用第一行的镜像源</p><p>完整镜像源列表可以参考<a class="link"   href="https://archlinux.org/mirrorlist/" >官方文档<i class="fas fa-external-link-alt"></i></a></p><ol start="8"><li><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2></li></ol><p>安装必需的基础包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-headers linux-firmware  <span class="comment">#base-devel在AUR包的安装是必须的</span></span><br></pre></td></tr></table></figure><p>可能有警告但是一定应该没有报错</p><p>如果报告“验证软件包错误”，可以尝试以下方法，然后重新安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init  <span class="comment"># 初始化密钥环</span></span><br><span class="line">pacman-key --populate</span><br><span class="line">pacman -Sy archlinux-keyring  <span class="comment"># 更新 archlinux-keyring</span></span><br></pre></td></tr></table></figure><p>安装必需的功能性软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt dhcpcd iwd vim bash-completion   <span class="comment">#一个有线所需(iwd也需要dhcpcd) 一个无线所需 一个编辑器 一个补全工具</span></span><br></pre></td></tr></table></figure><ol start="9"><li><h2 id="生成fstab文件"><a href="#生成fstab文件" class="headerlink" title="生成fstab文件"></a>生成fstab文件</h2></li></ol><p>fstab是一个系统文件，决定了系统启动时如何自动挂载分区。没有 fstab，系统将找不到根分区，从而无法启动。</p><p>Arch Linux 提供了自动生成 fstab 的工具，我们利用它直接生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>其中 <code>genfstab -U /mnt</code>是以 UUID 的描述方式生成 fstab，“&gt;&gt;” 的意思是，将输出结果附加在后面的文件之后。</p><p>生成完成后，记得使用 cat 命令打印文件内容，仔细检查一遍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /mnt/etc/fstab</span><br></pre></td></tr></table></figure><ol start="10"><li><h2 id="Change-root"><a href="#Change-root" class="headerlink" title="Change root"></a>Change root</h2></li></ol><p>我们使用 arch-chroot 工具切换到新安装的系统，以后的操作就可以在新安装的系统中完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><ol start="11"><li><h2 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h2></li></ol><p>将时区设置为中国上海</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>然后设置硬件时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><ol start="12"><li><h2 id="设置Locale进行本地化"><a href="#设置Locale进行本地化" class="headerlink" title="设置Locale进行本地化"></a>设置Locale进行本地化</h2></li></ol><p>Locale 决定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。</p><p>首先使用 vim 编辑 <code> /etc/locale.gen</code>，去掉 en_US.UTF-8 所在行以及 zh_CN.UTF-8 所在行的注释符号（#）。</p><p>这里需要使用 vim 的寻找以及编辑功能，具体可自行查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br><span class="line">locale-gen    <span class="comment">#编辑修改之后生成locale</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;LANG=en_US.UTF-8&#x27;</span>  &gt; /etc/locale.conf    <span class="comment">#最后向 /etc/locale.conf 导入内容</span></span><br></pre></td></tr></table></figure><ol start="13"><li><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2></li><li><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso ~]<span class="comment"># vim /etc/hostname</span></span><br><span class="line">----------------------------------</span><br><span class="line">我的主机名（myarch）</span><br></pre></td></tr></table></figure><ol start="2"><li><h3 id="网络管理器"><a href="#网络管理器" class="headerlink" title="网络管理器"></a>网络管理器</h3></li></ol><p>需要安装一个网络管理器，笔者推荐使用 NetworkManager。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S networkmanager</span><br></pre></td></tr></table></figure><p>NetworkManager  附带一个守护程序。在 Arch Linux 中，守护程序由 systemd 管理。systemd   是非常重要的系统程序。现在我们使用 systemd 设置 NetworkManager 开机自动启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> NetworkManager.service</span><br></pre></td></tr></table></figure><ol start="14"><li><h2 id="root密码"><a href="#root密码" class="headerlink" title="root密码"></a>root密码</h2></li></ol><p>设置root用户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso ~]<span class="comment"># passwd</span></span><br><span class="line">New password:  <span class="comment"># 请输入密码，这里不会显示“*”，这是正常现象</span></span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure><ol start="15"><li><h2 id="引导加载程序"><a href="#引导加载程序" class="headerlink" title="引导加载程序"></a>引导加载程序</h2></li></ol><p>推荐使用GRUB，本文章只针对UEFI启动模式的电脑，对于BIOS启动模式的电脑可查看<a class="link"   href="https://www.viseator.com/2017/05/17/arch_install/" >参考文章<i class="fas fa-external-link-alt"></i></a></p><ol><li><h3 id="安装微码"><a href="#安装微码" class="headerlink" title="安装微码"></a>安装微码</h3></li></ol><p>先查看CPU型号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep <span class="string">&quot;model name&quot;</span></span><br></pre></td></tr></table></figure><p>如果是 Intel CPU，安装 intel-ucode。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><p>如果是 AMD CPU，安装 amd-ucode。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S amd-ucode</span><br></pre></td></tr></table></figure><ol start="2"><li><h3 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr   <span class="comment">#grub是启动引导器，efibootmgr被 grub 脚本用来将启动项写入 NVRAM。</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>可以对配置文件进行修改：编辑&#x2F;etc&#x2F;default&#x2F;grub 文件，去掉 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>一行中最后的 quiet 参数，同时把 log level 的数值从 3 改成 5，这样是为了后续如果出现系统错误，方便排错。同时在同一行加入 nowatchdog 参数，这可以显著提高开关机速度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>最后生成GRUB所需的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><ol start="16"><li><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2></li></ol><p>首先退出chroot环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>然后关闭交换文件（如果有）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /mnt/swapfile</span><br></pre></td></tr></table></figure><p>随后，取消挂载&#x2F;mnt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount -R /mnt</span><br></pre></td></tr></table></figure><p>最后重启计算机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>至此基本的Arch Linux系统已安装成功</p><h1 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h1><ol><li><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2></li></ol><p>重启之后使用root账户登陆，然后连接wifi：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi list  <span class="comment"># 列出可连接的 WiFi</span></span><br><span class="line">nmcli device wifi connect <span class="string">&quot;SSID&quot;</span> password <span class="string">&quot;密码&quot;</span>  <span class="comment"># 连接 WiFi</span></span><br></pre></td></tr></table></figure><p>可以使用ping工具检验</p><ol start="2"><li><h2 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h2></li></ol><p>新安装的系统只有一个超级用户，即 root。使用 root 进行日常操作是不安全的。应当创建普通用户进行日常操作，仅在管理系统时使用 root。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx ~]# useradd -m -G wheel 用户名  # 创建用户，并为其创建家目录，将其加入 wheel 组</span><br><span class="line">[root@xxxx ~]# passwd 用户名  # 为新用户设置密码</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure><p>普通用户的权限又太低了，有时我们需要 root 权限进行系统管理，比如系统更新。这时我们需要提升权限。</p><p>为了提升权限，我们需要配置一个工具，我们的工具是 sudo</p><p>需要使用vim编辑 <code>/etc/sudoers</code>进行配置，由于该文件十分重要，推荐通过visudo工具编辑，该工具提供了语法检查，防止文件错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=vim visudo  <span class="comment">#需要以 root 用户运行 visudo 命令</span></span><br></pre></td></tr></table></figure><p>找到 <code>#%wheel ALL=(ALL:ALL) ALL</code>这一行，将#注释去掉，<code>：wq</code>保存退出</p><ol start="3"><li><h2 id="配置系统默认编辑器"><a href="#配置系统默认编辑器" class="headerlink" title="配置系统默认编辑器"></a>配置系统默认编辑器</h2></li></ol><p>编辑 <code>EDITOR=vim sudoedit /etc/profile</code> 文件，加入如下内容，将 vim 设置为默认 EDITOR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export EDITOR=&#x27;vim&#x27;</span><br></pre></td></tr></table></figure><p>这样就不用在每次执行命令时都指定一遍 <code>EDITOR=vim</code> 了。</p><p>重启之后可以使用 <code>sudo -e</code>编辑文件了</p><ol start="4"><li><h2 id="pacman配置"><a href="#pacman配置" class="headerlink" title="pacman配置"></a>pacman配置</h2></li></ol><p>pacman是 Arch Linux 的包管理器，负责安装、卸载、更新和查找软件包。我们为了让它更好地运行，需要进行如下配置：</p><ul><li>启用颜色显示</li><li>启用并行下载</li><li>启用 multilib 仓库</li><li>启用 archlinuxcn 仓库</li><li>安装 pkgstats</li></ul><p>主要是编辑 <code>/etc/pacman.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -e /etc/pacman.conf</span><br></pre></td></tr></table></figure><p>为了启用颜色显示和并行下载([12])，请取消 Color 和 ParallelDownloads &#x3D; 5 之前的“#”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/pacman.conf</span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="comment"># Misc options</span></span><br><span class="line">Color</span><br><span class="line">ParallelDownloads = 5</span><br></pre></td></tr></table></figure><p>其次，如果您需要在 Arch Linux 中运行 Steam 和 Wine（Steam 是 Valve 公司开发的游戏分发平台；Wine 是  Windows 兼容层，可以使您在 Linux 中运行 Windows 程序），请启用 multilib 仓库。该仓库提供 32  位软件包。请搜索“multilib”，取消下述两行之前的“#”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/pacman.conf</span><br><span class="line">-------------------------------------</span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlis</span><br></pre></td></tr></table></figure><p>然后，推荐启用 archlinuxcn 仓库。该仓库是由 Arch Linux 中文社区驱动的非官方软件仓库，包含许多官方仓库未提供的额外的软件包，以及已有软件的 git 版本等变种，提供了大量适合国人使用的软件包。</p><p>请在文件最后新建一行，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/pacman.conf</span><br><span class="line">-------------------------------------</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><p>如果您开启了 archlinuxcn 仓库，请安装 archlinuxcn-keyring。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br><span class="line">pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><p>如果 <code>pacman -S archlinuxcn-keyring</code>出现如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: archlinuxcn-keyring: signature from <span class="string">&quot;Jiachen YANG (Arch Linux  Packager Signing Key) &lt;farseerfc@archlinux.org&gt;&quot;</span> is marginal trust</span><br></pre></td></tr></table></figure><p>需要 <code>sudo pacman-key --lsign ``farseerfc@archlinux.org</code>具体见<a class="link"   href="https://bbs.archlinuxcn.org/viewtopic.php?id=13906" >ArchLinux论坛<i class="fas fa-external-link-alt"></i></a></p><p>最后，建议安装 pkgstats。这个软件包将您安装的软件列表、镜像源和计算机架构定期上传到 Arch Linux 官方，反馈该信息有利于系统的发展，这也是为开源社区的贡献。如果您不希望上传软件列表，请跳过此步。要想查看统计数据，请前往 <a class="link"   href="https://link.zhihu.com/?target=https://pkgstats.archlinux.de/" >pkgstats.archlinux.de<i class="fas fa-external-link-alt"></i></a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S pkgstats</span><br></pre></td></tr></table></figure><ol start="5"><li><h2 id="软件包缓存清理"><a href="#软件包缓存清理" class="headerlink" title="软件包缓存清理"></a>软件包缓存清理</h2></li></ol><p>使用 pacman 安装和更新软件包时，软件包会下载到 <code>/var/cache/pacman/pkg/ </code>目录下。久而久之，缓存会占据大量的存储空间。因此，定期清理软件包缓存是必要的。</p><p>推荐安装 pacman-contrib软件包，然后开机自动启动 paccache.timer，以便每周自动清理不使用的软件包缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S pacman-contrib</span><br><span class="line">systemctl <span class="built_in">enable</span> paccache.timer</span><br></pre></td></tr></table></figure><ol start="6"><li><h2 id="安装KDE桌面环境"><a href="#安装KDE桌面环境" class="headerlink" title="安装KDE桌面环境"></a>安装KDE桌面环境</h2></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin  <span class="comment">#安装plasma-meta元软件包以及终端和文件管理器</span></span><br></pre></td></tr></table></figure><ol start="7"><li><h2 id="配置SDDM"><a href="#配置SDDM" class="headerlink" title="配置SDDM"></a>配置SDDM</h2></li></ol><p>登陆屏幕</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure><ol start="8"><li><h2 id="安装基础功能包"><a href="#安装基础功能包" class="headerlink" title="安装基础功能包"></a>安装基础功能包</h2></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf                     #一些可能需要的声音固件</span><br><span class="line">sudo pacman -S ntfs-3g                                                      #识别NTFS格式的硬盘</span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei                   #安装几个开源中文字体 一般装上文泉驿就能解决大多wine应用中文方块的问题</span><br><span class="line">sudo pacman -S noto-fonts-cjk noto-fonts-emoji noto-fonts-extra             #安装谷歌开源字体及表情</span><br><span class="line">sudo pacman -S firefox chromium                                             #安装常用的火狐、谷歌浏览器</span><br><span class="line">sudo pacman -S ark                                                          #与dolphin同用右键解压</span><br><span class="line">sudo pacman -S p7zip unrar unarchiver lzop lrzip                            #安装ark可选依赖</span><br><span class="line">sudo pacman -S packagekit-qt5 packagekit appstream-qt appstream             #确保Discover(软件中心）可用 需重启</span><br><span class="line">sudo pacman -S gwenview                                                     #图片查看器</span><br><span class="line">sudo pacman -S git wget kate bind                                           #一些工具</span><br></pre></td></tr></table></figure><ol start="9"><li><h2 id="设置系统为中文"><a href="#设置系统为中文" class="headerlink" title="设置系统为中文"></a>设置系统为中文</h2></li></ol><p>设置中寻找，如果显示中文不全可能是 <code>~/.config/plasma-localerc</code> 里的 LANG 变量缺少 .UTF-8。</p><p>具体参考<a class="link"   href="https://bbs.archlinuxcn.org/viewtopic.php?id=13917" >ArchLinux论坛<i class="fas fa-external-link-alt"></i></a></p><ol start="10"><li><h2 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h2></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im <span class="comment">#基础包组</span></span><br><span class="line">sudo pacman -S fcitx5-chinese-addons <span class="comment">#官方中文输入引擎</span></span><br><span class="line">sudo pacman -S fcitx5-anthy <span class="comment">#日文输入引擎</span></span><br><span class="line">yay -S fcitx5-pinyin-moegirl <span class="comment">#萌娘百科词库 由于中国大陆政府对github封锁，你可能在此卡住。如卡住，可根据后文设置好代理后再安装</span></span><br><span class="line">sudo pacman -S fcitx5-pinyin-zhwiki <span class="comment">#中文维基百科词库</span></span><br><span class="line">sudo pacman -S fcitx5-material-color <span class="comment">#主题</span></span><br></pre></td></tr></table></figure><p>设置环境变量：编辑文件 <code>EDITOR=vim sudoedit /etc/environment</code> 加入以下内容。konsole 以及 dolphin 都需要这些环境变量，倒是 chrome 和 firefox 都不需要就可以输入中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure><p>打开  <em>系统设置区域设置输入法</em> ，先点击 <code>运行Fcitx</code>即可，拼音为默认添加项。如你还需要更多输入法如五笔，则再点击 <code>添加输入法</code>，找到简体中文下的五笔 ，点击添加即可加入五笔输入法。</p><p>接下来点击 <em>拼音</em> 右侧的配置按钮，点选 <code>云拼音</code>和 <code>在程序中显示预编辑文本</code> 最后应用。</p><p>回到输入法设置，点击 <code>配置附加组件</code>，找到 <em>经典用户界面</em> 在主题里选择一个你喜欢的颜色 最后应用。</p><p>注销，重新登陆，就可以发现已经可以在各个软件中输入中文了</p><h1 id="成为合格的系统管理员"><a href="#成为合格的系统管理员" class="headerlink" title="成为合格的系统管理员"></a>成为合格的系统管理员</h1><p><a class="link"   href="https://archlinuxstudio.github.io/ShellTutorial/#/" >LInux进阶书籍（基于ArchLInux）<i class="fas fa-external-link-alt"></i></a></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a class="link"   href="https://wiki.archlinuxcn.org/wiki/%E9%A6%96%E9%A1%B5" >ArchLinux文档<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin" >ArchLinuxStudio文档<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/568981775" >zhihu参考文档<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;启动U盘&quot;&gt;&lt;a href=&quot;#启动U盘&quot; class=&quot;headerlink&quot; title=&quot;启动U盘&quot;&gt;&lt;/a&gt;启动U盘&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://archlinux.org/download/&quot; &gt;下载镜像</summary>
      
    
    
    
    <category term="linux" scheme="https://zhaozhan.site/categories/linux/"/>
    
    
    <category term="ArchLinux" scheme="https://zhaozhan.site/tags/ArchLinux/"/>
    
    <category term="linux" scheme="https://zhaozhan.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu视频解码问题</title>
    <link href="https://zhaozhan.site/2024/02/19/ubuntu%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://zhaozhan.site/2024/02/19/ubuntu%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2024-02-19T10:17:34.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MP4视频解码器安装"><a href="#MP4视频解码器安装" class="headerlink" title="MP4视频解码器安装"></a>MP4视频解码器安装</h1><p><code>sudo apt install ubuntu-restricted-extras</code></p><p>如果安装之后出现<strong>找不到影片</strong>的错误</p><p>可能是原解码器占用</p><p><code>sudo apt remove gstreamer1.0-vaapi</code></p><p>卸载gstreamer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MP4视频解码器安装&quot;&gt;&lt;a href=&quot;#MP4视频解码器安装&quot; class=&quot;headerlink&quot; title=&quot;MP4视频解码器安装&quot;&gt;&lt;/a&gt;MP4视频解码器安装&lt;/h1&gt;&lt;p&gt;&lt;code&gt;sudo apt install ubuntu-restrict</summary>
      
    
    
    
    <category term="linux" scheme="https://zhaozhan.site/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zhaozhan.site/tags/linux/"/>
    
    <category term="ubuntu" scheme="https://zhaozhan.site/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>手机摄影</title>
    <link href="https://zhaozhan.site/2024/02/19/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/"/>
    <id>https://zhaozhan.site/2024/02/19/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1/</id>
    <published>2024-02-19T10:15:38.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手机摄影优势"><a href="#手机摄影优势" class="headerlink" title="手机摄影优势"></a>手机摄影优势</h1><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.3uuke5wv3i.webp"                        alt="图片"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7p0qn1khk.webp"                        alt="图片"                 ></p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ol><li><h2 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h2></li></ol><p>点击确定焦点位置</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.60tyzxpd04.webp"                        alt="图片"                 ></p><ol start="2"><li><h2 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h2></li></ol><p>摄影是光影的艺术</p><ul><li>正常曝光</li><li>过曝</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.1zhzljll1u.webp"                        alt="图片"                 ></p><ul><li>曝光不足</li></ul><p>手动点击拖动太阳图标上下划动</p><ol start="3"><li><h2 id="构图线"><a href="#构图线" class="headerlink" title="构图线"></a>构图线</h2></li></ol><p>在设置中可以打开构图线，有如下优点：</p><ul><li>辅助画面的稳定，有些手机可以开启水平仪，保证拍的照片水平不歪</li><li>九宫格帮助构图，见下文</li></ul><ol start="4"><li><h2 id="逆光"><a href="#逆光" class="headerlink" title="逆光"></a>逆光</h2></li></ol><p>打开HDR模式，可以明暗调节，防止过曝等情况</p><ol start="5"><li><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2></li></ol><p>景深：清晰范围，背景虚化属于小景深，整个照片都清晰属于大景深。</p><ul><li>人像模式：背景虚化，只适合拍人，不适合拍复杂场景，属于小景深</li><li>大光圈功能：更接近相机的景深效果，可以拍出背景虚化的效果</li><li>单镜头手机：手机与主体之间的距离&lt;主体与背景之间的距离，如此可以有虚化背景的效果，适合近距离拍摄</li></ul><ol start="6"><li><h2 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h2></li></ol><h3 id="九宫格："><a href="#九宫格：" class="headerlink" title="九宫格："></a>九宫格：</h3><p>主体不在中间</p><ol><li><p>记录光的环境</p></li><li><p>记录人和环境关系</p></li><li><p>人脸和视线方向留有空间</p></li><li><p>记录完整的信息，突出主体</p></li></ol><h3 id="中心构图："><a href="#中心构图：" class="headerlink" title="中心构图："></a>中心构图：</h3><p>主体在中间</p><p>运用自己的思维，使其显得不苍白突兀（doge）</p><h3 id="三角形构图："><a href="#三角形构图：" class="headerlink" title="三角形构图："></a>三角形构图：</h3><p>增加图片的稳定性</p><p>三个主体有大小主次之分</p><h3 id="对称构图："><a href="#对称构图：" class="headerlink" title="对称构图："></a>对称构图：</h3><p>有水面，玻璃等</p><h3 id="引导线构图："><a href="#引导线构图：" class="headerlink" title="引导线构图："></a>引导线构图：</h3><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7p3bx4hkhg.webp"                        alt="图片"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.4jnty6ntqd.webp"                        alt="图片"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.pf2f868oz.webp"                        alt="图片"                 ></p><p>大片既视感</p><ol start="7"><li><h2 id="去除路人"><a href="#去除路人" class="headerlink" title="去除路人"></a>去除路人</h2></li></ol><ul><li>苹果：长曝光功能</li><li>华为：流水快门</li></ul><ol start="8"><li><h2 id="胖-瘦"><a href="#胖-瘦" class="headerlink" title="胖-&gt;瘦"></a>胖-&gt;瘦</h2></li></ol><ul><li>胳膊粗：避免紧贴身体，可以通过叉腰等使胳膊上的肌肉紧张</li><li>肚子胖：双臂环抱或其他物品在前遮挡，叉腰手向前聚拢</li></ul><ol start="9"><li><h2 id="坐姿大长腿"><a href="#坐姿大长腿" class="headerlink" title="坐姿大长腿"></a>坐姿大长腿</h2></li></ol><p>尽量两腿姿态不同，增加画面层次感</p><ol start="10"><li><h2 id="人脸显瘦"><a href="#人脸显瘦" class="headerlink" title="人脸显瘦"></a>人脸显瘦</h2></li><li>拍侧脸</li><li>光源很近，增加轮廓</li><li><h2 id="拍出高挑效果"><a href="#拍出高挑效果" class="headerlink" title="拍出高挑效果"></a>拍出高挑效果</h2></li><li>低角度拍摄</li><li>腿在画面的底边缘</li><li><h2 id="错位摄影"><a href="#错位摄影" class="headerlink" title="错位摄影"></a>错位摄影</h2></li></ol><h1 id="专业模式"><a href="#专业模式" class="headerlink" title="专业模式"></a>专业模式</h1><p>以华为手机为例</p><blockquote><p>注意：使用专业模式能够影响的仅仅是画面的曝光和色彩，对画面效果最终的影响不是最决定性的因素。</p></blockquote><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.9gwas13idh.webp"                        alt="图片"                 ></p><ul><li>调整画面色彩：<ul><li>白平衡（AWB&#x2F;WB）：点击进入白平衡有很多白平衡模式，通常手机默认的是自动白平衡（AWB），还有阴天、白天、日光等各种不同的模式，切换这些不同的白平衡模式，能够改变的，就只是画面的色彩而已。</li></ul></li><li>调整画面对焦：<ul><li>对焦模式（AF）：通常AF是自动对焦，MF是手动对焦，AF-S 单次自动对焦，用于拍摄静止物体，点触屏幕对焦后需快速按下快门拍摄。AF-C连续自动对焦，用于拍摄移动物体，手机会自动跟踪移动物体对焦。</li></ul></li><li>调整画面曝光：<ul><li>曝光补偿（EV）：主要作用是提升或降低整体画面的曝光（亮度）</li><li>感光度（ISO）：主要影响镜头中的感光元件对光线的敏感&#x2F;吸收，感光度越高，画面曝光越高，感光度越低，画面曝光越偏暗</li><li>快门速度（S）：曝光时长的长短，影响画面的进光量，快门速度越慢，镜头的进光量越多，画面曝光就越亮；反之，快门速度越快，画面曝光就越暗。</li></ul></li></ul><p>最后，测光模式一般不需调整，对画面的影响几乎可以忽略，其实用不同的测光模式，得到的画面曝光差别都不大，没有调整的意义，通常就用手机默认的测光模式即可。</p><h1 id="夜景模式"><a href="#夜景模式" class="headerlink" title="夜景模式"></a>夜景模式</h1><p>以<a class="link"   href="https://zhidao.baidu.com/search?word=iPhone%2011&fr=iknow_pc_qb_highlight" >iPhone 11<i class="fas fa-external-link-alt"></i></a>手机为例，夜景模式的实现原理：A13仿生处理器加软件。简单来说，当传感器侦测到拍摄场景的环境光线不足时，夜景模式会自动开启，这时如果拍摄者为iPhone准备了脚架或者矿泉水瓶等让设备稳定的器材时，按下快门后，摄像头会拍摄多张照片，同时光学防抖功能也会开启。在同样的光线环境下，iPhone 11夜景模式的照片要比不支持夜景模式的iPhone照片要亮得多。</p><p>接下来就轮到功能强大的<a class="link"   href="https://zhidao.baidu.com/search?word=A13%E5%A4%84%E7%90%86%E5%99%A8&fr=iknow_pc_qb_highlight" >A13处理器<i class="fas fa-external-link-alt"></i></a>出场了，处理器会进行运算，用相机软件将多张照片进行拼合，调整<a class="link"   href="https://zhidao.baidu.com/search?word=%E5%AF%B9%E6%AF%94%E5%BA%A6&fr=iknow_pc_qb_highlight" >对比度<i class="fas fa-external-link-alt"></i></a>，精修颜色，智能去噪，增强细节，并生成最终图像。</p><h1 id="解读6400万像素模式"><a href="#解读6400万像素模式" class="headerlink" title="解读6400万像素模式"></a>解读6400万像素模式</h1><p>转一篇手机像素和相机像素的区别：</p><blockquote><p>像素单位是没有区别的，它代表了分辨率。</p><p>但是，图片的质量并不是由“像素”这一个单位决定的，用过ps都知道，创建画布时，会有两个图片质量单位：</p><p>分辨率代表了像素点的多少，例如1920×1080，就代表大约200w像素</p><p>而像素密度-ppi代表每英寸内像素数量</p><p>举个栗子，一个4英寸屏幕的手机可以是1920×1080，一个17英寸笔记本电脑也大多是1920×1080的分辨率（只不过一个横着一个竖着）很明显，如果看显示的精细度，无疑手机的更加精细，因为他只用了4英寸就显示了足够多的像素，假如用这个手机屏拼出17寸的大小，那它将拥有3000w像素</p><p>也就是说单用分辨率，是不能说明一张图片的质量的。</p><p>在物理上真正决定相机画质的东西是感光元件CMOS，摄像头负责采集像素点，而CMOS负责记录收集到的光信息，CMOS的尺寸越大，其接受的光信息就越多越好，拍出来的图片质量越好，噪点就会越少。</p><p>如果拆开单反镜头你就会发现，最小的残幅相机CMOS也会比手机大n倍。</p><p>所以“媲美单反”这样的说法就是唬人的，单反或微单的优势就在于CMOS的尺寸更大。</p><p>手机镜头广告只说分辨率，不说ppi，只是利用广大消费者知识面的欠缺的营销，</p><p>这就像是只告诉你田有多大面积，不告诉你单位粮食产量一样</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>图片资源来源于网上，侵权速删</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手机摄影优势&quot;&gt;&lt;a href=&quot;#手机摄影优势&quot; class=&quot;headerlink&quot; title=&quot;手机摄影优势&quot;&gt;&lt;/a&gt;手机摄影优势&lt;/h1&gt;&lt;p&gt;&lt;img  
                       lazyload
               </summary>
      
    
    
    
    <category term="生活" scheme="https://zhaozhan.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="摄影" scheme="https://zhaozhan.site/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习</title>
    <link href="https://zhaozhan.site/2024/02/19/MySQL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhaozhan.site/2024/02/19/MySQL%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-19T10:13:20.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://blog.csdn.net/qq_35409127/article/details/79760797" >参考命令<i class="fas fa-external-link-alt"></i></a></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol><li><h2 id="Access-denied-for-user-‘root‘-’localhost’"><a href="#Access-denied-for-user-‘root‘-’localhost’" class="headerlink" title="Access denied for user ‘root‘@’localhost’"></a>Access denied for user ‘root‘@’localhost’</h2></li></ol><p>在运行 MySQL 5.7（及更高版本）的 Ubuntu 系统中，MySQL root 用户默认设置为使用 auth_socket 插件进行身份验证，而不是使用密码。在许多情况下，这可以提供更高的安全性和可用性，但当您需要允许外部程序（例如，vscode mysql插件）访问用户时，它也会使事情变得复杂。为了使用密码以 root 身份连接到 MySQL，您需要将其身份验证方法从 auth_socket 切换为mysql_native_password。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql    <span class="comment">#进入mysql终端</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;your_new_password&#x27;</span>;    <span class="comment">#修改密码的同时将验证方式改为密码验证</span></span><br><span class="line">FLUSH PRIVILEGES    <span class="comment">#刷新特权</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_35409127/article/details/79760797&quot; &gt;参考命令&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://zhaozhan.site/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://zhaozhan.site/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="https://zhaozhan.site/2024/02/19/redis%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhaozhan.site/2024/02/19/redis%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-19T10:12:05.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍与安装"><a href="#介绍与安装" class="headerlink" title="介绍与安装"></a>介绍与安装</h1><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指 <strong>非关系型数据库</strong> 。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a class="link"   href="https://github.com/microsoftarchive/redis/releases" >Windows版redis下载地址<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://download.redis.io/releases/" >Linux版redis下载地址<i class="fas fa-external-link-alt"></i></a></p><p>windows中下载的.zip包直接解压即可</p><h1 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h1><h2 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h2><ul><li>Windows：redis.windows.conf</li><li>Linux：redis.conf</li></ul><h2 id="配置参数："><a href="#配置参数：" class="headerlink" title="配置参数："></a>配置参数：</h2><ul><li>daemonize：yes将redis控制为后台运行，Windows不支持</li><li>Requirepass foobared：配置密码，默认为注释的状态</li><li>bind：允许远程连接的客户端ip，默认为127.0.0.1，可以注释掉允许所有远程客户端连接</li></ul><p>启动redis服务：<code>./redis-server.exe ./redis.windows.conf</code>；也可以直接双击.exe文件启动</p><h2 id="可设置参数："><a href="#可设置参数：" class="headerlink" title="可设置参数："></a>可设置参数：</h2><ol><li>-h：指定连接的Redis服务的ip地址</li><li>-p：指定连接的Redis服务的端口号</li><li>-a：指定连接的Redis服务的密码</li></ol><h1 id="redis数据类型及其命令行操作"><a href="#redis数据类型及其命令行操作" class="headerlink" title="redis数据类型及其命令行操作"></a>redis数据类型及其命令行操作</h1><h2 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h2><p>redis中的数据全是key-value结构，key类型都是string</p><p>value可以是：</p><ul><li>字符串string：普通常用</li><li>哈希hash：适合存储对象</li><li>列表list：按照插入顺序排序，可有重复元素</li><li>集合set：无序集合，没有重复元素</li><li>有序集合sorted set&#x2F;zset：每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul><p>参考图片：</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7ljpzec6q8.webp"                        alt="图片"                 ></p><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><h3 id="value为string"><a href="#value为string" class="headerlink" title="value为string"></a>value为string</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line"><span class="comment">#设置只当的key值</span></span><br><span class="line">GET key</span><br><span class="line"><span class="comment">#获取指定key的值</span></span><br><span class="line">SETEX key seconds value</span><br><span class="line"><span class="comment">#设置指定key的值，并把过期时间设为seconds秒</span></span><br><span class="line">SETNX key value</span><br><span class="line"><span class="comment">#只在不存在key的时候设置key的值</span></span><br></pre></td></tr></table></figure><p>更多命令参考<a class="link"   href="https://www.redis.net.cn/" >Redis中文网<i class="fas fa-external-link-alt"></i></a></p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br><span class="line"><span class="comment">#查找所有符合给定模式（pattern）的key</span></span><br><span class="line">EXISTS key</span><br><span class="line"><span class="comment">#检查给定key是否存在</span></span><br><span class="line">TYPE key</span><br><span class="line"><span class="comment">#返回key所存储的值的类型</span></span><br><span class="line">TTL key</span><br><span class="line"><span class="comment">#返回给定key的剩余时间（TTL：time to live），以秒为单位</span></span><br><span class="line">DEL key</span><br><span class="line"><span class="comment">#在key存在时删除key</span></span><br></pre></td></tr></table></figure><h1 id="go语言操作redis"><a href="#go语言操作redis" class="headerlink" title="go语言操作redis"></a>go语言操作redis</h1><h2 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h2><p>两种redis方式支持go操作</p><ol><li><code>go get -u github.com/go-redis/redis</code></li><li><code>go get -u github.com/garyburd/redigo/redis</code></li></ol><p>只记录第一种</p><h2 id="启动服务和监控"><a href="#启动服务和监控" class="headerlink" title="启动服务和监控"></a>启动服务和监控</h2><p>双击 <code>redis-server.exe</code> 和 <code>redis-cli.exe</code> 启动服务</p><p>在客户端命令行输入命令 <code>monitor</code> 开启监控</p><p>开启监控后所有操作都会在客户端命令行中打印出来</p><h2 id="go连接Redis"><a href="#go连接Redis" class="headerlink" title="go连接Redis"></a>go连接Redis</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rd := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:6379&quot;</span>, <span class="comment">// url</span></span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        DB:<span class="number">0</span>,   <span class="comment">// 0号数据库</span></span><br><span class="line">    &#125;)</span><br><span class="line">    result, err := rd.Ping().Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;ping err :&quot;</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><ul><li>获取zset长度</li></ul><p><code>lenth, err := client.ZCard(context.Background(), key).Result()</code></p><ul><li>根据score删除部分元素</li></ul><p><code>_, err = client.ZRemRangeByRank(context.Background(), key, 0, </code> <em><code>ZsetShrinkNum</code></em> <code>-1).Result()</code></p><ul><li>添加元素</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, err = client.ZAdd(context.Background(), key, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="type">float64</span>(messageID),</span><br><span class="line">    Member: messageID,</span><br><span class="line">&#125;).Result()</span><br></pre></td></tr></table></figure><p>参考资料：</p><p>go语言redis方法：<a class="link"   href="https://juejin.cn/post/7202521955366879288" >https://juejin.cn/post/7202521955366879288<i class="fas fa-external-link-alt"></i></a></p><p>go语言配置redis：<a class="link"   href="https://blog.csdn.net/lena7/article/details/120828397" >https://blog.csdn.net/lena7/article/details/120828397<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍与安装&quot;&gt;&lt;a href=&quot;#介绍与安装&quot; class=&quot;headerlink&quot; title=&quot;介绍与安装&quot;&gt;&lt;/a&gt;介绍与安装&lt;/h1&gt;&lt;p&gt;Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。&lt;/p&gt;
&lt;p&gt;Redis是用</summary>
      
    
    
    
    <category term="redis" scheme="https://zhaozhan.site/categories/redis/"/>
    
    
    <category term="redis" scheme="https://zhaozhan.site/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://zhaozhan.site/2024/02/19/WebSocket/"/>
    <id>https://zhaozhan.site/2024/02/19/WebSocket/</id>
    <published>2024-02-19T10:09:25.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>WebSocket 协议提供了一种全双工的通信机制, 服务端可以主动向客户端推送数据, WebSocket 协议采用了 HTTP 协议来握手, 与 HTTP 使用相同的默认端口, 这一切都是为了兼容现有的 HTTP 组件或代理, 但 WebSocket 与 HTTP 是相互独立的协议, 二者并不存在上下的层级关系, WebSocket 的正式协议文档为 <a class="link"   href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6455" >[RFC 6455]<i class="fas fa-external-link-alt"></i></a>, 本文全面讨论 WebSocket 协议的设计与工作原理</p><h1 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h1><h2 id="客户端请求upgrade"><a href="#客户端请求upgrade" class="headerlink" title="客户端请求upgrade"></a>客户端请求upgrade</h2><p>WebSocket 协议的第一步是进行握手, WebSocket 握手采用 HTTP Upgrade 机制, 客户端可以发送如下所示的结构发起握手 (请注意 WebSocket 握手只允许使用 HTTP GET 方法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><ul><li>在 HTTP Header 中设置 Upgrade 字段, 其字段值为 websocket, 并在 Connection 字段指示 Upgrade</li><li>| Sec-WebSocket-Key |, 必传, 由客户端随机生成的 16 字节值, 然后做 base64 编码, 客户端需要保证该值是足够随机, 不可被预测的 (换句话说, 客户端应使用熵足够大的随机数发生器), 在 WebSocket 协议中, 该头部字段必传, 若客户端发起握手时缺失该字段, 则无法完成握手</li><li>| Sec-WebSocket-Version |, 必传, 指示 WebSocket 协议的版本, <a class="link"   href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6455" >RFC 6455<i class="fas fa-external-link-alt"></i></a> 的协议版本为 13, 在 <a class="link"   href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6455" >RFC 6455<i class="fas fa-external-link-alt"></i></a> 的 Draft 阶段已经有针对相应的 WebSocket 实现, 它们当时使用更低的版本号, 若客户端同时支持多个 WebSocket 协议版本, 可以在该字段中以逗号分隔传递支持的版本列表 (按期望使用的程序降序排列), 服务端可从中选取一个支持的协议版本</li><li>| Sec-WebSocket-Protocol |, 可选, 客户端发起握手的时候可以在头部设置该字段, 该字段的值是一系列客户端希望在于服务端交互时使用的子协议 (subprotocol), 多个子协议之间用逗号分隔, 按客户端期望的顺序降序排列, 服务端可以根据客户端提供的子协议列表选择一个或多个子协议</li><li>| Sec-WebSocket-Extensions |, 可选, 客户端在 WebSocket 握手阶段可以在头部设置该字段指示自己希望使用的 WebSocket 协议拓展</li></ul><h2 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h2><p>服务端若支持 WebSocket 协议, 并同意握手, 可以返回如下所示的结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><ul><li>| Sec-WebSocket-Accept |, 必传, 客户端发起握手时通过 | Sec-WebSocket-Key | 字段传递了一个将随机生成的 16 字节做 base64 编码后的字符串, 服务端若接收握手, 则应将该值与 WebSocket 魔数 (Magic Number) “258EAFA5-E914-47DA- 95CA-C5AB0DC85B11” 进行字符串连接, 将得到的字符串做 SHA-1 哈希, 将得到的哈希值再做 base64 编码, 最终的值便是该字段的值；当客户端收到服务端的握手响应后, 会做同样的运算来校验该值是否符合预期, 以便于判断服务端是否真的支持 WebSocket 协议</li><li>| Sec-WebSocket-Protocol |, 可选, 若客户端在握手时传递了希望使用的 WebSocket 子协议, 则服务端可在客户端传递的子协议列表中选择其中支持的一个, 服务端也可以不设置该字段表示不希望或不支持客户端传递的任何一个 WebSocket 子协议</li><li>| Sec-WebSocket-Extensions |, 可选, 与 Sec-WebSocket-Protocol 字段类似, 若客户端传递了拓展列表, 可服务端可从中选择其中一个做为该字段的值, 若服务端不支持或不希望使用这些扩展, 则不设置该字段</li><li>| Sec-WebSocket-Version |, 必传, 服务端从客户端传递的支持的 WebSocket 协议版本中选择其中一个, 若客户端传递的所有 WebSocket 协议版本对服务端来说都不支持, 则服务端应立即终止握手, 并返回 HTTP 426 状态码, 同时在 Header 中设置 | Sec-WebSocket-Version | 字段向客户端指示自己所支持的 WebSocket 协议版本列表</li></ul><p>若客户端校验服务端的握手响应通过, 则 WebSocket 握手阶段完成, 接下来双方就可以进行 WebSocket 的双向数据传输了</p><h1 id="WebSocket-数据帧-frame"><a href="#WebSocket-数据帧-frame" class="headerlink" title="WebSocket 数据帧 (frame)"></a>WebSocket 数据帧 (frame)</h1><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.1serq3pro3.webp"                        alt="图片"                 ></p><p>具体参考文章<a class="link"   href="https://zhuanlan.zhihu.com/p/407711596" >https://zhuanlan.zhihu.com/p/407711596<i class="fas fa-external-link-alt"></i></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>WebSocket 协议主要为了解决 HTTP&#x2F;1.x 缺少双向通信机制的问题, 它使用 TCP 作为传输层协议, 使用 HTTP Upgrade 机制来握手, WebSocket 使用与 HTTP 相同的 80 (WebSocket over TCP) 和 443 (WebSocket over TLS) 端口, 它与 HTTP 是相互独立的协议, 二者没有上下的分层关系, 了解更详细的 WebSocket 细节可以阅读 <a class="link"   href="https://link.zhihu.com/?target=https://tools.ietf.org/html/rfc6455" >RFC 6455<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;WebSocket 协议提供了一种全双工的通信机制, 服务端可以主动向客户端推送数据, WebSocket 协议采用了 HTTP 协议来握手</summary>
      
    
    
    
    <category term="im" scheme="https://zhaozhan.site/categories/im/"/>
    
    
    <category term="im" scheme="https://zhaozhan.site/tags/im/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://zhaozhan.site/2024/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhaozhan.site/2024/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-02-19T10:06:31.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1></li></ol><p>有时候需要确保在高并发的场景下有些事情只执行一次，比如加载配置文件、关闭管道等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oc sync.Once</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                oc.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        a++</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                oc.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        a++</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Println(a) <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h1 id=&quot;单例&quot;&gt;&lt;a href=&quot;#单例&quot; class=&quot;headerlink&quot; title=&quot;单例&quot;&gt;&lt;/a&gt;单例&lt;/h1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有时候需要确保在高并发的场景下有些事情只执行一次，比如加载配置文件、关闭管道等。&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="设计模式" scheme="https://zhaozhan.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://zhaozhan.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>云原生概述</title>
    <link href="https://zhaozhan.site/2024/02/19/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://zhaozhan.site/2024/02/19/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2024-02-19T10:04:47.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云原生的出现"><a href="#云原生的出现" class="headerlink" title="云原生的出现"></a>云原生的出现</h1><h2 id="云计算的发展"><a href="#云计算的发展" class="headerlink" title="云计算的发展"></a>云计算的发展</h2><p>云计算的发展大致分为三个阶段：</p><p>虚拟化的出现-&gt;虚拟化的应用-&gt;容器化</p><ol><li><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3></li></ol><p>表示将计算机资源分成逻辑组的技术</p><p>同一台物理机器上运行多个虚拟机</p><ol start="2"><li><h3 id="虚拟机的市场化应用"><a href="#虚拟机的市场化应用" class="headerlink" title="虚拟机的市场化应用"></a>虚拟机的市场化应用</h3></li></ol><p>亚马逊AWS在2006年公开发布S3存储服务、SQS消息队列及EC2虚拟机服务，正式宣告了现代云计算的到来</p><p>云服务的三种模型满足了不同消费者的需求：</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.ibujsdlvx.webp"                        alt="图片"                 ></p><ul><li>IaaS：基础设施服务，主要提供基础的硬件资源</li><li>PaaS：平台服务，提供软件部署平台，开发者只需关注自己的业务逻辑，不需要关系硬件和操作系统细节</li><li>SaaS：软件服务，提供一系列服务，拿来即用</li></ul><p>更多请查看：<a class="link"   href="https://blog.csdn.net/weixin_43972437/article/details/103307609" >IaaS、PaaS、SaaS、BaaS、FaaS和Serverless的含义<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li><h3 id="容器化和容器编排的兴起"><a href="#容器化和容器编排的兴起" class="headerlink" title="容器化和容器编排的兴起"></a>容器化和容器编排的兴起</h3></li></ol><p>容器化：虚拟化的改进版本</p><p>区别：</p><ul><li>虚拟化：在硬件级别分离应用程序</li><li>容器化：在操作系统级别分离硬件程序</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.5tqr4i09vv.webp"                        alt="图片"                 ></p><p>2018年起开始占据统治地位。</p><h2 id="云计算云原生"><a href="#云计算云原生" class="headerlink" title="云计算&lt;-&gt;云原生"></a>云计算&lt;-&gt;云原生</h2><p>云原生就是云计算的下半场</p><p>云原生不是一种架构，而是一种基础设施，运行在其上的应用称作云原生应用，只有符合云原生设计哲学的应用架构才叫做云原生架构。</p><h2 id="云原生出现"><a href="#云原生出现" class="headerlink" title="云原生出现"></a>云原生出现</h2><p>由于对业务快速迭代，团队规模不断增大，产品交付速度增大的应对，微服务和云原生开始出现</p><p>pivotal是云原生概念的提出者，他提出云原生包括以下四个方面</p><h1 id="云原生四要素"><a href="#云原生四要素" class="headerlink" title="云原生四要素"></a>云原生四要素</h1><h2 id="微服务："><a href="#微服务：" class="headerlink" title="微服务："></a>微服务：</h2><p>几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。</p><p>微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。</p><h2 id="容器化："><a href="#容器化：" class="headerlink" title="容器化："></a>容器化：</h2><p>Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西</p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps:"></a>DevOps:</h2><p>这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。</p><h2 id="持续交付："><a href="#持续交付：" class="headerlink" title="持续交付："></a>持续交付：</h2><p>持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。</p><h1 id="云原生的优点"><a href="#云原生的优点" class="headerlink" title="云原生的优点"></a>云原生的优点</h1><ol><li>新兴语言编写：go，node.js</li><li>支持持续频繁更新，持续交付</li><li>本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。</li><li>本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。</li><li>部署和运维都是自动化。</li><li>不会硬连接到任何系统环境中，只依赖抽象的基础架构，有很好的移植效果</li><li>模块化更加合理。</li></ol><h1 id="云原生的定义"><a href="#云原生的定义" class="headerlink" title="云原生的定义"></a>云原生的定义</h1><p>云原生的定义在不断的发展，它实际上是一种理论或者说是方法论。</p><p>目前最为系统的云原生应用开发指南：12因素（12-Factors：<a class="link"   href="https://12factor.net)/" >https://12factor.net）<i class="fas fa-external-link-alt"></i></a></p><p>12因素为任何语言开发的后端应用服务提供好的方法论和核心思想：</p><ol><li>使用声明式格式搭建自动化，便于新来者加入</li><li>和底层操作系统保持简约的契约，保证可移植性</li><li>适合在现代的云平台上部署</li><li>最小化开发和生产之间的分歧，实现持续部署以实现最大的灵活性</li><li>在工具、架构和开发实践不发生重大变化的前提下实现扩展</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.9gwas0wgjb.webp"                        alt="图片"                 ></p><h1 id="云原生的基础架构"><a href="#云原生的基础架构" class="headerlink" title="云原生的基础架构"></a>云原生的基础架构</h1><ol><li><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2></li></ol><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.41xs9lhon6.webp"                        alt="图片"                 ></p><p>微服务：</p><ul><li>优点：降低系统复杂度，独立部署，独立拓展，跨语言编程</li><li>缺点：运维带来挑战，分布式系统复杂性问题</li></ul><ol start="2"><li><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2></li></ol><p>一个操作系统下的多个隔离，每个隔离一个容器，每个容器都有唯一的可写文件系统和资源配额</p><p>特点：</p><ul><li>隔离应用依赖</li><li>创建应用镜像并复制</li><li>创建容易分发的即启即用的应用</li><li>支持实例简单</li><li>快速地拓展</li></ul><p>docker：开源应用容器引擎</p><p>用户可以将为微服务及其所需的所有配置、依赖关系和环境变量打包成容器镜像，并轻松一直到全新的安装了docker的服务器节点上，运维人员无须关系底层操作系统，且无须重新配置环境，这使得容器成为部署单个微服务的最理想的工具。</p><p>因为人为部署麻烦</p><p>容器分为两部分：</p><ul><li>运行层：容器的基础设施，包括存储、网络、CPU等</li><li>编排层：主要是容器集群的管理，包括容器调度，服务注册和发现，资源的管理等</li></ul><p>相关工具：Kubernetes</p><p>Kubernetes目前基本算是统一了容器编排的市场，实现了容器集群的自动化部署，扩缩容和维护等功能，和docker相辅相成。</p><ol start="3"><li><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2></li></ol><p>微服务技术架构：</p><ul><li>侵入式架构：服务框架嵌入程序代码，RPC、负载均衡、熔断等</li><li>非侵入式架构：以代理的形式和应用程序部署在一起，接管应用程序的网络且对其透明，以服务网格为代表。</li></ul><p>为解决侵入性问题，引入了 Service Mesh</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7smxuu6v0y.webp"                        alt="图片"                 ></p><p>Service Mesh处理服务间请求&#x2F;响应的可靠传递，并可用于服务治理、遗留系统的零入侵接入以及异构框架开发的微服务，实现了轻量级的网络代理。</p><ol start="4"><li><h2 id="不可变基础设施和DevOps"><a href="#不可变基础设施和DevOps" class="headerlink" title="不可变基础设施和DevOps"></a>不可变基础设施和DevOps</h2></li></ol><p>不可变基础设施：</p><p>主要强调基础设施的状态性质</p><p>一旦创建基础设施的实例,其将会变成只读状态</p><p>如果后续需要修改和升级，则需要使用新的实例替换旧实例</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7p0qn0cht.webp"                        alt="图片"                 ></p><p>DevOps的目标是缩短开发周期，增加部署频率更可靠地发布升级系统应用</p><p>DevOps和云原生架构的结合能够实现精益产品开发流程帮助软件产品及其开发持续改进，适应快速变化的市场从而为企业提供更小的试错成本</p><ol start="5"><li><h2 id="声明式API"><a href="#声明式API" class="headerlink" title="声明式API"></a>声明式API</h2></li></ol><ul><li>声明式设计：指通过向工具描述自己想要让事物达到的目标状态，然后由这个工具自己内部去计算如何令这个事物达到目标状态声明式设计中描述的是目标状态,即How</li><li>过程式设计：所描述的是一系列的动作，即 What</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;云原生的出现&quot;&gt;&lt;a href=&quot;#云原生的出现&quot; class=&quot;headerlink&quot; title=&quot;云原生的出现&quot;&gt;&lt;/a&gt;云原生的出现&lt;/h1&gt;&lt;h2 id=&quot;云计算的发展&quot;&gt;&lt;a href=&quot;#云计算的发展&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="系统架构" scheme="https://zhaozhan.site/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="系统架构" scheme="https://zhaozhan.site/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>微服务概述</title>
    <link href="https://zhaozhan.site/2024/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://zhaozhan.site/2024/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2024-02-19T10:02:09.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务端架构的演进"><a href="#服务端架构的演进" class="headerlink" title="服务端架构的演进"></a>服务端架构的演进</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.86tdlp9bro.webp"                        alt="图片"                 ></p><p>将所有的服务端功能模块打包成单个巨石型应用</p><p>缺点：</p><ul><li>局部改动就需要重新部署，编译时间过长</li><li>技术栈不宜拓展</li><li>只能在原有的基础上进行局部的优化</li></ul><h2 id="垂直分层架构"><a href="#垂直分层架构" class="headerlink" title="垂直分层架构"></a>垂直分层架构</h2><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7p3bx48e8u.webp"                        alt="图片"                 ></p><p>缺点:</p><ul><li>垂直分层架构的系统拆分使得集群搭建变得复杂</li><li>涉及到的服务间调用服务之间耦合度变高，调用关系错综复杂,难以维护调用关系</li></ul><h2 id="SOA面向服务架构"><a href="#SOA面向服务架构" class="headerlink" title="SOA面向服务架构"></a>SOA面向服务架构</h2><p>当垂直架构拆分的应用越来越多的时候，出现多个应用都依赖的业务逻辑组件，并且各个应用进行交互的需要也越来越频繁，此时需要将部分通用的业务组件独立出来，并定义好服务间交互的接口，向外提供能力，让其他服务调用，SOA面向服务架构就“应运而生”</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.ibujsad9e.webp"                        alt="图片"                 ></p><p>  缺点：</p><ul><li>适用于大型软件服务企业对外提供服务的场景，对于一般的业务场景并不适用</li><li>其服务的定义、注册和调用都需要较为繁琐的编码或配置实现</li><li>业务总线容易导致系统的单点风险并拖累整体性能</li></ul><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.8aczjf3od7.webp"                        alt="图片"                 ></p><p>特点：</p><ul><li>系统服务层完全独立出来，并将服务层抽取为一个个的微服务</li><li>微服务遵循单一原则</li><li>微服务之间采用RESTful等轻量协议通信</li><li>微服务一般使用容器技术部署，运行在自己的独立的进程中，合理分配其所需的系统资源</li><li>每个微服务都有自己独立的业务开发活动和周期</li></ul><p>缺点：</p><ul><li>拆分的服务实例不能过多</li><li>服务之间相互依赖，可能形成复杂的依赖链条</li><li>服务实例之间交互需要处理分布式事务、调用幂等性和重试等问题，开发成本高，对团队的挑战大</li></ul><h2 id="微服务框架的选型"><a href="#微服务框架的选型" class="headerlink" title="微服务框架的选型"></a>微服务框架的选型</h2><p>随着微服务架构的火热，也诞生了很多微服务框架如：Java的Spring Cloud、Go语言的Go Kit和Go Micro以及Node.js的Seneca</p><h1 id="go语言微服务框架"><a href="#go语言微服务框架" class="headerlink" title="go语言微服务框架"></a>go语言微服务框架</h1><p>go语言的独特优势：</p><ul><li>语法简单，上手快</li><li>原生支持并发</li><li>丰富的标准库</li><li>部署方便</li></ul><h2 id="Go-kit框架"><a href="#Go-kit框架" class="headerlink" title="Go-kit框架"></a>Go-kit框架</h2><p>go-kit提供了用于实现系统监控和弹性模式组件的库，例如日志记录、跟踪、限流和熔断等，这些库协助工程师提高微服务架构的性能和稳定性，Go-kit框架分层如图</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.wiaanjeem.webp"                        alt="图片"                 ></p><p>基于Go-kit的应用程序架构有三个主要的部分组成：传输层、接口层、服务层</p><ul><li>传输层：用于网络通信，使用HTTP或gRPC等网络传输方式，或使用NATS等发布订阅系统相互通信，除此之外，Go-kit还支持使用AMQP和Thrift等多种网络通信模式</li><li>接口层：服务器和客户端的基本构建块，在Go-kit服务中的每个对外提供的接口方法都会定义为一个端点（Endpoint），以便在服务器和客户端之间进行网络通信。每个端点使用传输层通过使用HTTP或gRPC等具体通信模式对外提供服务。</li><li>服务层：具体的业务实现。服务层的业务逻辑包含核心业务逻辑，不会也不应该进行HTTP或gRPC等具体网络传输，或者请求和响应消息类型的编码和解码。</li></ul><p>Go-kit在性能和拓展性等各方面表现优异。</p><h2 id="Go-Micro框架"><a href="#Go-Micro框架" class="headerlink" title="Go Micro框架"></a>Go Micro框架</h2><p>Go Micro是基于Go语言实现的插件化RPC微服务框架</p><p>它提供了服务发现、负载均衡、同步传输、异步通信以及事件驱动等机制并尝试去简化分布式系统间的通信</p><p>让开发者可以专注于自身业务逻辑的开发。</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.wiaanjtv3.webp"                        alt="图片"                 ></p><p>如图所示三层堆栈</p><p>Go Mircro是组件化的框架，每个基础功能都有对应的接口抽象，方便拓展，还有可插拔的特点</p><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><ul><li>Go-kit：微服务的标准库，提供独立的包，通过这些包，开发者可以用来组建自己的应用程序，微服务架构意味着构建分布式系统，这带来了许多的挑战，Go-kit可以为多数业务场景下实施微服务软件架构提供指导和解决方案</li><li>Go Micro：是一个面向微服务的可插拔RPC 框架，可以快速启动微服务的开发，Go Micro框架提供了许多功能，无需重新“造轮子”所以开发者可以花更多的时间在需要关注的业务逻辑上但是Go Micro在快速启动微服务开发的同时，也牺牲了灵活性，并且将gRPC强制为默认通信类型更换组件不如Go Kit简便</li></ul><h1 id="云原生与微服务架构的关系"><a href="#云原生与微服务架构的关系" class="headerlink" title="云原生与微服务架构的关系"></a>云原生与微服务架构的关系</h1><p>从云原生定义可以知道，微服务架构是云原生的关键技术之一</p><p>从本质上来说，云原生和微服务是两种不同维度的技术</p><ul><li>云原生：更侧重应用程序的运行环境，它是以k8s和容器为基础的云环境</li><li>微服务架构：对应于应用程序的软件架构</li></ul><h1 id="微服务的设计"><a href="#微服务的设计" class="headerlink" title="微服务的设计"></a>微服务的设计</h1><p>微服务有六大设计原则：</p><ol><li>高内聚，低耦合</li><li>高度自治</li><li>以业务为中心</li><li>弹性设计</li><li>日志和监控</li><li>自动化</li></ol><h1 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h1><h2 id="设计微服务的困境"><a href="#设计微服务的困境" class="headerlink" title="设计微服务的困境"></a>设计微服务的困境</h2><p>路径依赖法则：在人类社会中的技术演进或制度变迁均有类似于物理学中的惯性，即一旦进入某一路径（无论是好是坏），就可能对这种路径产生依赖。</p><p>在这种情况下，由单体架构演进到微服务架构就变得不是那么简单了。</p><p>微服务不是“小”服务，在微服务架构落地实践的过程中，工程师往往会遇到微服务的粒度与边界划分等实践问题，DDD是解决这些问题的关键技术之一，它是一套完整且系统的设计方法。</p><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>DDD主要用于合理地划分业务系统以及保持业务架构和系统架构的一致性这两个领域，DDD可以有效地根据业务对复杂软件系统进行拆解，微服务架构和DDD相得益彰</p><h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p>以购物车下单为例：</p><ul><li>用户界面：提供下单接口</li><li>应用层：业务逻辑的整合</li><li>领域层：业务逻辑的实现和封装</li><li>基础设施层：底层数据库</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.lsv7ak4l.webp"                        alt="图片"                 ></p><h3 id="领域和子域"><a href="#领域和子域" class="headerlink" title="领域和子域"></a>领域和子域</h3><p>一个业务中的所有内容构成了这个业务系统唯一的领域，，其划分的子业务就是子域</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.361au55bd5.webp"                        alt="图片"                 ></p><p>核心域：顾名思义</p><p>支撑子域：支撑核心域的实现</p><p>通用子域：耦合的部分，如用户鉴权等</p><h3 id="限界上下文和通用语言"><a href="#限界上下文和通用语言" class="headerlink" title="限界上下文和通用语言"></a>限界上下文和通用语言</h3><p>限界上下文和子域一一对应，将限界上下文中的所有概念集中在一起，我们创建一套通用的语言，相关人员使用通用语言直接交流</p><h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><p>从层级职能组织变为小团体集群组织</p><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><ul><li>微服务架构的复杂性：在微服务架构中，微服务组件复杂、上手门槛比较高成为了痛点问题，对于业务开发人员来说，微服务仅仅是手段，不是最终的目标，我们需要对业务开发人员“屏蔽”微服务的基础组件，使得微服务之间的通信对于业务开发人员透明</li></ul><p>为了应对这个问题，有些实践是利用API网关接收请求，网关作为代理处理外部服务的请求，并提供服务注册与发现、负载均衡、日志监控、容错等功能，它可以解决从用户到各个后端服务的流量问题，而我们需要的是一个完整的贯穿整个请求周期的方案，或者至少是一些能够与API网关互补的方案和工具</p><ul><li>微服务本身的挑战：自身引入的复杂度，版本的兼容性等</li></ul><p>服务间通信是最需要解决的问题</p><p>serice Mesh通过独立进程的方式隔离微服务基础组件对这个独立进程升级、运维要比传统的微服务方式简单得多</p><h2 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h2><ul><li>定义：</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7w6jsjxa8g.webp"                        alt="图片"                 ></p><ul><li>Service Mesh模式的核心在于将客户端SDK剥离，以Proxy独立进程运行，目标是将原来存在于SDK中的各种能力下沉，为应用减负，以帮助应用云原生化</li><li>Service Mesh逐步发展成一个独立的基础设施层</li></ul><p>Sidecar：应用系统可能由数百个微服务组成微服务一般又是多实例部署，并且每一个实例都可能处于不断变化的状态，因为它们是由Kubernetes之类的资源调度系统动态调度Kubernetes中的 Service Mesh实现模式被命名为Sidecar(边车模式，因为类似连接到摩托车的边车)</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.syocxs7wl.webp"                        alt="图片"                 ></p><h2 id="三种组件"><a href="#三种组件" class="headerlink" title="三种组件"></a>三种组件</h2><h4 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h4><p>由google、IBM和Lyft合作开源，基本只支持在kubernetes运行</p><h4 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h4><p>由两部分控制平面和数据平面两个方面的架构</p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>C++编写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务端架构的演进&quot;&gt;&lt;a href=&quot;#服务端架构的演进&quot; class=&quot;headerlink&quot; title=&quot;服务端架构的演进&quot;&gt;&lt;/a&gt;服务端架构的演进&lt;/h1&gt;&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="系统架构" scheme="https://zhaozhan.site/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="系统架构" scheme="https://zhaozhan.site/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习</title>
    <link href="https://zhaozhan.site/2024/02/19/Linux%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhaozhan.site/2024/02/19/Linux%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-19T09:59:58.000Z</published>
    <updated>2024-02-21T03:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进入Linux"><a href="#进入Linux" class="headerlink" title="进入Linux"></a>进入Linux</h1><p>终端：</p><ul><li>图形终端</li><li>命令行终端<ul><li>$表示普通用户</li><li>#表示root用户</li><li><code>Init 3</code>命令选择登录用户，<code>init 0</code>命令退出系统，<code>su - root</code>切换为root权限</li></ul></li><li>远程终端（ssh vnc）</li></ul><p>常见目录结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">/root root用户的家目录</span><br><span class="line">/home/username 普通用户的家目录</span><br><span class="line">/etc 配置文件目录</span><br><span class="line">/bin 命令目录</span><br><span class="line">/sbin 管理命令目录</span><br><span class="line">/usr/bin /usr/sbin 系统预装的其他命令</span><br></pre></td></tr></table></figure><h1 id="学习命令"><a href="#学习命令" class="headerlink" title="学习命令"></a>学习命令</h1><h2 id="Man"><a href="#Man" class="headerlink" title="Man"></a>Man</h2><ul><li>Man ls</li><li>Man mancat</li><li>Man 7 man</li></ul><p>man手册的九个章节：</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.5q756rt3dh.webp"                        alt="图片"                 ></p><h2 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h2><ul><li>内部命令：Help cd</li><li>外部命令：Ls –help</li><li>查看类型：type cd</li></ul><h2 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h2><ul><li>Info cd</li></ul><p>补充help</p><h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><ul><li>Pwd 显示当前目录名称</li><li>Cd 更改当前操作目录<ul><li>Cd - 回到刚才的目录</li><li>Cd .&#x2F;.. 相对路径</li><li>Cd &#x2F;.. 绝对路径</li></ul></li><li>Ls 查看当前目录的文件<ul><li>Ls  [目录 目录 …]</li><li>Ls -l 长格式输出</li><li>Ls -a 查看所有包括隐藏文件夹</li><li>Ls -r 逆向顺序显示（文件名逆向）</li><li>Ls -R 递归全部显示</li></ul></li></ul><h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><ul><li>Mkdir 创建目录<ul><li>Mkdir [目录 目录 …]</li><li>Mkdir -p [目录]同时创建多级目录</li></ul></li><li>Rmdir 删除空白目录</li><li>Rm -r -f 删除目录同时非提示</li></ul><h2 id="复制和移动目录"><a href="#复制和移动目录" class="headerlink" title="复制和移动目录"></a>复制和移动目录</h2><ul><li>Cp -r [源目录&#x2F;文件] [目的地址]<ul><li>-v 显示进度条</li><li>-p 保留时间</li><li>-a 保留属主和权限</li></ul></li><li>Mv 移动&#x2F;改名<ul><li>Mv [源目录] [目的目录]（目的地址不存在就是改名）</li></ul></li><li>通配符：*，？</li></ul><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul><li>Cat [文件名]</li><li>Head -5 [文件名] 查看开头5行</li><li>tail同head</li><li>-f 跟踪变化</li><li>Wc 查看多少行</li><li>More 分行显示</li></ul><h2 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h2><p>打包：</p><ul><li>Tar cf [目录和文件名] [要打包的目录]</li></ul><p>压缩:</p><ul><li>Gzip</li><li>bzip2</li><li>Tar czf [tmp&#x2F;ect.backup.tar.gz] [&#x2F;etc]</li><li>Tar cjf [tmp&#x2F;ect.backup.tar.bz2] [&#x2F;etc]</li></ul><p>解压缩:</p><ul><li>Tar xf &#x2F;tmp&#x2F;etc-backup.tar -C &#x2F;root<ul><li>Zxf</li></ul></li></ul><h2 id="Vi"><a href="#Vi" class="headerlink" title="Vi"></a>Vi</h2><h3 id="四种模式："><a href="#四种模式：" class="headerlink" title="四种模式："></a>四种模式：</h3><p>正常模式、插入模式、命令模式、可视模式</p><ul><li>退出： :q</li><li>编辑：i</li></ul><h3 id="正常模式："><a href="#正常模式：" class="headerlink" title="正常模式："></a>正常模式：</h3><p>进入输入模式：i，o，a或大写</p><p>进入可视化模式：v</p><p>进入命令模式：：</p><p>单行复制：yy</p><p>粘贴：p</p><p>多行复制：n yy</p><p>单行到结尾：y$</p><p>剪切：y-d</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><ul><li>保存：：w [目录]</li><li>不保存：:q!</li><li>执行linux命令:：！</li><li>查找：&#x2F;x</li><li>下移：n</li><li>上移：shift+n</li><li>替换：:%s&#x2F;old&#x2F;new&#x2F;g</li><li>替换：:3,5s&#x2F;old&#x2F;new&#x2F;g</li><li>显示行号：:set nu</li><li>查看vim配置文件：vim &#x2F;etc&#x2F;vimrc</li><li>到底端:shift+g</li></ul><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><ul><li>操作字符：v</li><li>操作行：V</li><li>操作块：ctrl+v</li></ul><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul><li>新建用户：useradd username</li><li>验证用户的存在：id username</li><li>指定用户密码：passwd username</li><li>改变自己的密码：passwd</li><li>删除用户：userdel username<ul><li>-r 删除home目录</li></ul></li><li>修改用户属性：usermod username<ul><li>-d 目录 修改home目录</li><li>Chage</li></ul></li><li>新建组：groupadd groupname</li><li>切换用户：su - username</li><li>授予user权限：visudo</li></ul><h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><ul><li>&#x2F;etc&#x2F;passwd</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.9kfwpqbmmf.webp"                        alt="图片"                 ></p><p>username:passwd:uid:gid:注释:家目录:命令解释器</p><ul><li>&#x2F;etc&#x2F;shadow</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.5q756rub7z.webp"                        alt="图片"                 ></p><p>username:加密之后的密码</p><ul><li>&#x2F;etc&#x2F;group</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.13li62w5zt.webp"                        alt="图片"                 ></p><p>groupname:passwd:gid:还在其他组的用户</p><h2 id="用户目录权限"><a href="#用户目录权限" class="headerlink" title="用户目录权限"></a>用户目录权限</h2><ul><li>查看文件权限：ls -l name</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.77da8izc1a.webp"                        alt="图片"                 ></p><ul><li>文件类型：</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.es8m29jni.webp"                        alt="图片"                 ></p><ul><li>权限表示：<ul><li>读：r</li><li>写：w</li><li>执行：x</li></ul></li></ul><blockquote><p>不同文件类型不同，权限限制只限制普通用户</p></blockquote><h2 id="修改权限命令"><a href="#修改权限命令" class="headerlink" title="修改权限命令"></a>修改权限命令</h2><ul><li>修改文件权限<ul><li>修改字符权限：chmod u&#x3D;rwx file<ul><li>属主权限：u</li><li>属组权限：g</li><li>其他权限：o</li><li>所有权限：a</li></ul></li><li>修改数字权限：chmod：446 file</li></ul></li><li>修改属主<ul><li>改属主：chown username dir</li><li>改属组：chown :groupname dir</li><li>或用chgrp</li></ul></li></ul><blockquote><p>权限冲突，以属主的权限为准</p></blockquote><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><ul><li>网络查看<ul><li>net.tools<ol><li>查看网卡名称：ifconfig<ol><li>修改网卡名称<br><img                         lazyload                       alt="image"                       data-src="https://diangroup.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTYzYWFhZDVhYWE0MjVmYjI3ZThhZmY4MWY4ODg0MDFfQ1JFdjBiWmJDak04YklnVGlmSFJYcVJ3UzJUaWJxTm1fVG9rZW46U3EyV2JsUktMb3laOEZ4Nm53V2NWM1dRbjJnXzE3MDgzMzY3ODE6MTcwODM0MDM4MV9WNA"                                        ></li></ol></li><li>查看路由：route</li><li>添加删除路由：route add&#x2F;del …</li><li>网络故障排除<ol><li>查看网络是否畅通：ping ip</li><li>检查每一跳的信息：traceroute -w 1 <a class="link"   href="http://www.baidu.com或者mtr/" >www.baidu.com或者mtr<i class="fas fa-external-link-alt"></i></a></li><li>域名解析：nslookup 域名</li><li>检测指定ip端口：telnet ip</li><li>网络抓包：tcpdump -i any -n host 10.0.0.1 and port 80 -w &#x2F;tmp&#x2F;file</li><li>查看监听端口：netstat&#x2F;ss -ntpl<ol><li>-n 只显示ip</li><li>-t 只显示tcp</li><li>-p 也显示进程</li><li>-l listen</li></ol></li></ol></li></ol></li><li>iproute2</li></ul></li><li>网络服务管理<ul><li>配置文</li></ul></li></ul><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="rpm格式"><a href="#rpm格式" class="headerlink" title="rpm格式"></a>rpm格式</h3><p>使用yum包管理器，如CentOS、RedHat</p><p>格式：软件名称-软件版本-系统版本-平台.rpm</p><h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><p>如果rpm包在设备文件&#x2F;dev中、查看镜像文件需要挂载</p><p><code>mount /dev/sr0 /mnt</code>将光盘文件挂载到mnt中ls可查看</p><p><code>cd packages</code>在这里可以查看到rpm文件</p><p><code>rpm -qa</code>查询安装的所有rpm包</p><p><code>rpm -qa | more</code>分页查询安装的所有rpm包</p><p><code>rpm -q 包名</code>查询安装的指定rpm包</p><p><code>rpm -i 包名</code>安装指定rpm包</p><p><code>rpm -e 包名</code>卸载安装的指定的rpm包</p><h4 id="yum命令管理"><a href="#yum命令管理" class="headerlink" title="yum命令管理"></a>yum命令管理</h4><p>yum管理下载rpm包，存在包镜像，可以改为国内的镜像源,可以不用考虑依赖关系</p><p><code>yum install ...</code></p><p><code>yum remove ...</code></p><p><code>yum update ...</code></p><h4 id="源代码编译安装"><a href="#源代码编译安装" class="headerlink" title="源代码编译安装"></a>源代码编译安装</h4><ul><li>wget下载.tar.gz</li><li>tar -zxf解压缩</li><li>cd进入</li><li>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;name配置安装位置</li><li>make编译</li><li>Make install编译好的进行安装</li></ul><h3 id="deb格式"><a href="#deb格式" class="headerlink" title="deb格式"></a>deb格式</h3><p>使用apt包管理器，如Debian、Ubuntu</p><h2 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h2><h3 id="rpm内核"><a href="#rpm内核" class="headerlink" title="rpm内核"></a>rpm内核</h3><p>查看内核版本：uname -r</p><h4 id="使用yum命令"><a href="#使用yum命令" class="headerlink" title="使用yum命令"></a>使用yum命令</h4><p>升级内核版本：yum install kernel-3…（<a class="link"   href="http://www.kernel.org)/" >www.kernel.org）<i class="fas fa-external-link-alt"></i></a></p><p>升级其他软件以及最新内核：yum update</p><p>安装依赖包：yum install</p><p>也可以使用源代码编译安装（&#x2F;usr&#x2F;src&#x2F;kernels）</p><h3 id="GRUB引导"><a href="#GRUB引导" class="headerlink" title="GRUB引导"></a>GRUB引导</h3><p>配置文件</p><p>&#x2F;etc&#x2F;default&#x2F;grub</p><p>&#x2F;etc&#x2F;grub.d</p><p>&#x2F;boot&#x2F;grub</p><p>grub可以修改默认引导的内核</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>查看进程：</p><ul><li>ps：查看当前运行进程：pid tty（终端）time  cmd<ul><li>ps -e | more 分页查看所有进程</li><li>-f 看到有效用户id,ppid（父进程）,cmd补全</li><li>-lf 看到线程</li></ul></li><li>pstree | more进程以树状形式显示</li><li>top查看全局进程信息</li></ul><p>进程控制：</p><ul><li>调整优先级</li><li>nice -n 10 .&#x2F;a.sh</li><li>renice -n 15 pid</li></ul><p>作业控制</p><ul><li>在后台运行：.&#x2F;a.sh &amp;</li><li>调到前台：jobs查看后台进程信息，fg 1 调到前台</li><li>ctrl+Z调到后台，同时停止进程</li><li>前台运行：fg,后台运行：bg</li></ul><p>进程通信：</p><p>管道符、信号、套接字</p><ul><li>查看信号：kill - l<ul><li>2号：SIGINT相当于ctrl+C</li><li>9号：SIGKILL不可中断的停止</li></ul></li><li>发送信号：kill - 9 pid</li></ul><p>守护进程：</p><p>不需要终端就可以启动</p><ul><li>关掉终端不会杀死进程同时忽略输入，输出到nohup.out中：nohup 程序 &amp;</li></ul><p>screen环境：</p><ul><li>screen：进入screen环境</li><li>ctrl+A+D退出会话</li><li>Screen -ls：查看会话</li><li>Screen -r id：重新进入会话</li><li>exit：退出会话</li></ul><p>系统日志：</p><ul><li>cd &#x2F;var&#x2F;log</li><li>&#x2F;messages常用系统日志</li><li>&#x2F;dmesg内核启动日志</li><li>&#x2F;secure安全问题</li></ul><p>服务管理工具：</p><p>systemctl</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进入Linux&quot;&gt;&lt;a href=&quot;#进入Linux&quot; class=&quot;headerlink&quot; title=&quot;进入Linux&quot;&gt;&lt;/a&gt;进入Linux&lt;/h1&gt;&lt;p&gt;终端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形终端&lt;/li&gt;
&lt;li&gt;命令行终端&lt;ul&gt;
&lt;li&gt;$表示普通</summary>
      
    
    
    
    <category term="linux" scheme="https://zhaozhan.site/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zhaozhan.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>构建GoWeb服务器</title>
    <link href="https://zhaozhan.site/2024/02/19/%E6%9E%84%E5%BB%BAGoWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://zhaozhan.site/2024/02/19/%E6%9E%84%E5%BB%BAGoWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-02-19T09:57:49.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>HTTP协议没有状态，即同一个客户端两次请求没有对应关系，为了解决这个问题引入session和cookie的概念</p><ol><li><h3 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h3></li></ol><p>http请求由请求行（Request Line）和请求头部(Header)、空行和请求数据等4个部分组成。</p><ul><li><p>请求行：方法  URL  版本  cr lf（\r\n）</p></li><li><p>请求头部：<br>字段名  字段值 cr lf</p><p>字段名  字段值 cr lf</p><p>…</p></li><li><p>空行：cr lf</p></li><li><p>请求数据（请求体）：（其他数据）</p></li></ul><ol start="2"><li><h3 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h3></li></ol><p>服务器接收到请求之后会做出响应，也是四部分组成：状态行、响应头、空行、响应体</p><ul><li><p>状态行：协议版本号  状态码  cr lf</p></li><li><p>响应头：（客户端可以使用的一些信息如Date（生成响应的日期）、Content-Type（MIME类型及编码格式）和Connection（默认是长连接）等等）<br>字段名  字段值 cr lf</p><p>字段名  字段值 cr lf</p><p>…</p></li><li><p>空行：cr lf</p></li><li><p>响应体：（响应正文）</p></li></ul><p>不同状态码对应信息：</p><ul><li>1XX：接收的请求正在处理</li><li>2XX：请求正常处理完毕</li><li>3XX：需要进行附加操作以完成请求</li><li>4XX：服务器无法处理请求</li><li>5XX：服务器处理请求出错</li></ul><h2 id="访问web站点的过程"><a href="#访问web站点的过程" class="headerlink" title="访问web站点的过程"></a>访问web站点的过程</h2><ol><li>输入url之后，浏览器先访问DNS服务器获取需访问服务器的真实ip</li><li>找到真实ip对应的服务器，建立tcp连接</li><li>浏览器发送HTTP Request</li><li>服务器接受到HTTP Request之后响应HTTP Response给浏览器</li><li>浏览器接收完HTTP Response之后断开tcp连接</li></ol><h1 id="使用Go语言构建服务器"><a href="#使用Go语言构建服务器" class="headerlink" title="使用Go语言构建服务器"></a>使用Go语言构建服务器</h1><p>【实例】</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, handler)    <span class="comment">//设置访问路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)    <span class="comment">//设置监听窗口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe:&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    _ = r.ParseForm()    <span class="comment">//解析参数，默认不会解析</span></span><br><span class="line">    fmt.Println(r.Form)    <span class="comment">//打印表单信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Path:&quot;</span>,r.URL.Path)    <span class="comment">//打印路由</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Host:&quot;</span>,r.Host)    <span class="comment">//打印ip/端口</span></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> r.Form&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>,k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>,strings.Json(v,<span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    _,_ = fmt.Fprintf(w, <span class="string">&quot;Hello Web,%s!&quot;</span>,r.Form.Get(<span class="string">&quot;name&quot;</span>))    <span class="comment">//将内容写到http.ResponseWriter中，发送到客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在浏览器中访问http://localhost:8080/hello?name=Extious</span></span><br><span class="line"><span class="comment">    即可得到响应结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="接收和处理请求"><a href="#接收和处理请求" class="headerlink" title="接收和处理请求"></a>接收和处理请求</h1><h2 id="Web工作中的几个概念"><a href="#Web工作中的几个概念" class="headerlink" title="Web工作中的几个概念"></a>Web工作中的几个概念</h2><p>net&#x2F;http标准库中由客户端和服务端两个部分</p><ul><li>服务端：Server,ServerMux,Handler&#x2F;HandlerFunc,Header,Request,Cookie</li><li>客户端：Client,Response,Header,Request,Cookie</li></ul><p>Conn:表示用户每次请求链接</p><p>http包服务端执行流程：</p><ol><li>创建Listen Socket，监听指定的端口，等待客户端的请求</li><li>Listen Socket接收到请求，得到Client Socket，通过Client Socket与客户端通信</li><li>服务端处理请求：从Client Socket中读取请求体，交给Handler处理，将响应体通过Client Socket写给客户端</li></ol><h2 id="处理器处理请求"><a href="#处理器处理请求" class="headerlink" title="处理器处理请求"></a>处理器处理请求</h2><p>流程：</p><ol><li>ListenAndServe进行监听：net.Listen(“tcp”,addr)</li><li>接收请求并创建连接Conn：srv.Serve(l net.Listener)：进入循环{rw :&#x3D; Accept();c :&#x3D; srv.NewConn();go c.serve()}</li><li>处理链接conn.serve()：分析请求，映射url</li></ol><h2 id="解析请求体"><a href="#解析请求体" class="headerlink" title="解析请求体"></a>解析请求体</h2><p>具体可见”使用Go语言构建服务器”中的【实例】</p><h2 id="返回响应体"><a href="#返回响应体" class="headerlink" title="返回响应体"></a>返回响应体</h2><p>主要通过接口ResponseWriter接口中的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">    Header() Header    <span class="comment">//通过set方法可以修改请求头中的某字段的内容</span></span><br><span class="line">    Write([]<span class="type">byte</span>) (<span class="type">int</span>,err)    <span class="comment">//使用json.Marshal（mapname）;w.Write(json)设置响应体</span></span><br><span class="line">    WriteHeader(statusCode <span class="type">int</span>)    <span class="comment">//修改状态码：默认是200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践案例：Golang-Web-框架-Gin-实践"><a href="#实践案例：Golang-Web-框架-Gin-实践" class="headerlink" title="实践案例：Golang Web 框架 Gin 实践"></a>实践案例：Golang Web 框架 Gin 实践</h1><ol><li><h2 id="Gin安装"><a href="#Gin安装" class="headerlink" title="Gin安装"></a>Gin安装</h2></li></ol><p><code>go get -u github.com/gin-gonic/gin</code></p><ol start="2"><li><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2></li></ol><p>直接引入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span><span class="comment">//可选，当使用http.StatusOK（200的状态码）这类的常量的时候需引入</span></span><br><span class="line">）</span><br></pre></td></tr></table></figure><ol start="3"><li><h2 id="使用Gin实现HTTP服务器"><a href="#使用Gin实现HTTP服务器" class="headerlink" title="使用Gin实现HTTP服务器"></a>使用Gin实现HTTP服务器</h2></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    router := gin.Default()    <span class="comment">//使用Default方法创建路由handler</span></span><br><span class="line">    router.GET(<span class="string">&quot;/ping&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;    <span class="comment">//通过http方法绑定路由规则和路由函数，这里是匿名函数</span></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;    <span class="comment">//gin把request和response封装在了一起：gin.Context</span></span><br><span class="line">            <span class="string">&quot;message&quot;</span>:<span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(:<span class="number">8000</span>)    <span class="comment">//通过Run方法启动监听路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><h2 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h2></li></ol><p>常用Restful方法有：GET,PUT,POST,DELETE等</p><p>路由的一些使用技巧和方式：</p><p>比如：由中携带参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/user/:name&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK,<span class="string">&quot;Hello %s&quot;</span>,name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上可以使用c.Param(s)（”name”）方法读取参数的值，但是gin不支持路由正则表达式，只有像 <code>/user/Extious</code> 这个结构的路由才可以被匹配，而 <code>/user</code> ,<code>/user/</code>,<code>/user/Extious/</code>都不会被匹配。</p><p>gin还提供了”*”处理参数：</p><p><code>router.GET(&quot;/user/:name/*action&quot;,func）</code>这个时候处理器可以匹配到 <code>/user/Extious/</code>,<code>/user/Extious/Send</code>,<code>/user/Extious</code></p><blockquote><p>注意：路由参数是指API参数和URL参数不同，URL参数是路由之后 <code>/api?name=&quot;Extious&quot;</code> 里边name这种，需要用到Query()等方法遍历到</p></blockquote><ol start="5"><li><h2 id="gin中间件"><a href="#gin中间件" class="headerlink" title="gin中间件"></a>gin中间件</h2></li></ol><p>中间件的意思是对一组接口的统一操作，常用于：记录log，错误handler，对部分接口的鉴权</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;gin-http/middleware&quot;</span></span><br><span class="line">    <span class="string">&quot;gin-http/model&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.Use(AuthMiddleware())</span><br><span class="line">    router.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        user := model.User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;user&quot;</span>: user&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 从请求头中获取token值</span></span><br><span class="line">        token := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        <span class="comment">// 验证token是否有效，这里仅做示例，实际应用中需要调用相关接口进行验证</span></span><br><span class="line">        <span class="keyword">if</span> token == <span class="string">&quot;valid_token&quot;</span> &#123;</span><br><span class="line">            c.Next() <span class="comment">// 验证通过，继续执行后续中间件和请求处理方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.String(http.StatusUnauthorized, <span class="string">&quot;Token is invalid&quot;</span>) <span class="comment">// 验证失败，返回错误信息</span></span><br><span class="line">            c.Abort() <span class="comment">// 终止请求处理，不再执行后续中间件和请求处理方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务端数据存储"><a href="#服务端数据存储" class="headerlink" title="服务端数据存储"></a>服务端数据存储</h1><p>MySQL采用gorm的一系列接口</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;http协议&quot;&gt;&lt;a href=&quot;#http协议&quot; class=&quot;headerlink&quot; title=&quot;http协议&quot;&gt;&lt;/a&gt;http协议&lt;/h2&gt;&lt;p&gt;HTTP协议没有状态，即同一个客户端两次请求没有对应关系，为了解决这个问题引入session和cookie的</summary>
      
    
    
    
    <category term="golang" scheme="https://zhaozhan.site/categories/golang/"/>
    
    
    <category term="golang" scheme="https://zhaozhan.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>makefile学习</title>
    <link href="https://zhaozhan.site/2024/02/19/makefile%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhaozhan.site/2024/02/19/makefile%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-19T09:53:22.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从代码到可执行文件需要预处理，编译，汇编和链接这几个步骤。</p><p>而一个项目有多个源文件，如果只修改一个，就对所有源文件重新执行编译、链接步骤，就太浪费时间了，因此十分有必要引入 Makefile 工具：Makefile 工具可以根据文件依赖，自动找出那些需要重新编译和链接的源文件，并对它们执行相应的动作。</p><h1 id="makefile三要素"><a href="#makefile三要素" class="headerlink" title="makefile三要素"></a>makefile三要素</h1><p>目标，依赖，执行语句：</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.5c0pfwo9eg.webp"                        alt="图片"                 ></p><h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">main : main.c</span><br><span class="line">        gcc main.c -o main</span><br></pre></td></tr></table></figure><h2 id="通配符和使用wildcard函数"><a href="#通配符和使用wildcard函数" class="headerlink" title="通配符和使用wildcard函数"></a>通配符和使用wildcard函数</h2><p>Wildcard function使用方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern…)</span></span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">main : <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">        gcc <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> -o main</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量使用通配符"><a href="#变量使用通配符" class="headerlink" title="变量使用通配符"></a>变量使用通配符</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(SRCS)</span></span><br><span class="line">        gcc <span class="variable">$(SRCS)</span> -o main</span><br></pre></td></tr></table></figure><h2 id="赋值和修改"><a href="#赋值和修改" class="headerlink" title="赋值和修改"></a>赋值和修改</h2><h3 id="递归赋值"><a href="#递归赋值" class="headerlink" title="递归赋值"></a>递归赋值</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:;echo <span class="variable">$(foo)</span></span></span><br><span class="line"><span class="comment"># 打印的结果为 Huh?，$(foo)展开得到$(bar)，$(bar)展开得到$(ugh)，$(ugh)展开得到Huh?最终$(foo)展开得到Huh?</span></span><br></pre></td></tr></table></figure><h3 id="简单赋值"><a href="#简单赋值" class="headerlink" title="简单赋值"></a>简单赋值</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line"><span class="comment"># 等效于：</span></span><br><span class="line"><span class="comment"># y := foo bar</span></span><br><span class="line"><span class="comment"># x := later</span></span><br></pre></td></tr></table></figure><h3 id="文本添加"><a href="#文本添加" class="headerlink" title="文本添加"></a>文本添加</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line"><span class="comment"># objects最终为main.o foo.o bar.o utils.o another.o</span></span><br></pre></td></tr></table></figure><h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br><span class="line"><span class="comment"># FOO最终为bar</span></span><br><span class="line">foo := ugh</span><br><span class="line">foo ?= Huh?</span><br><span class="line"><span class="comment"># foo最终为ugh</span></span><br></pre></td></tr></table></figure><h1 id="Makefile进阶"><a href="#Makefile进阶" class="headerlink" title="Makefile进阶"></a>Makefile进阶</h1><h2 id="应对复杂的目录结构"><a href="#应对复杂的目录结构" class="headerlink" title="应对复杂的目录结构"></a>应对复杂的目录结构</h2><p>当前的目录结构为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── entry.c</span><br><span class="line">├── func</span><br><span class="line">│   ├── bar.c</span><br><span class="line">│   └── bar.h</span><br><span class="line">└── main</span><br></pre></td></tr></table></figure><p>使用foreach函数遍历所有的头文件和源文件</p><p>使用方法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#the list</span></span><br><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"><span class="comment">#find .h file</span></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line"><span class="comment">#find .c file</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"><span class="comment">#go</span></span><br><span class="line">main : <span class="variable">$(SRCS)</span></span><br><span class="line">        gcc <span class="variable">$(INCS)</span> <span class="variable">$(SRCS)</span> -o main</span><br></pre></td></tr></table></figure><p>图示详解：</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.b8moci3rl.webp"                        alt="图片"                 ></p><h2 id="分析编译过程"><a href="#分析编译过程" class="headerlink" title="分析编译过程"></a>分析编译过程</h2><ul><li>预处理：预处理器将以字符 <code>#</code> 开头的命令展开、插入到原始的C程序中。比如我们在源文件中能经常看到的、用于头文件包含的 <code>#include</code> 命令，它的功能就是告诉预编译器，将指定头文件的内容插入的程序文本中，生成 <code>.i</code>文本文件。下图示解析：</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.6f0eqsl78n.webp"                        alt="图片"                 ></p><ul><li>编译阶段：编译器将文本文件 <code>*.i</code> 翻译成文本文件 <code>*.s</code>，它包含一个汇编语言程序。</li><li>汇编阶段：汇编器将 <code>*.s</code> 翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，并保存在 <code>*.o</code> 文件中。</li><li>链接阶段：在 <code>bar.c</code> 中我们定义了 <code>Print_Progress_Bar</code> 函数，该函数会保存在目标文件 <code>bar.o</code> 中。直到链接阶段，链接器才以某种方式将 <code>Print_Progress_Bar</code> 函数合并到 <code>main</code> 函数中去。在链接时如果没有指定 <code>bar.o</code>，链接器就无法找到 <code>Print_Progress_Bar</code> 函数，也就会提示找不到相关函数的定义。</li></ul><h2 id="模式规则和自动变量（两个问题）"><a href="#模式规则和自动变量（两个问题）" class="headerlink" title="模式规则和自动变量（两个问题）"></a>模式规则和自动变量（两个问题）</h2><p>目前要解决两个问题</p><ol><li>没有保存 <code>.o</code> 文件，这导致我们每次文件变动都要重新执行预处理、编译和汇编来得到目标文件，即使新得到的文件与旧文件完全没有差别（即编译用到的源文件没有任何变化，就跟 <code>bar.c</code> 一样）。</li><li>有保存 <code>.o</code> 文件，则会遇到第二个问题，即依赖中没有指定头文件，这意味着只修改头文件的情况下，源文件不会重新编译得到新的可执行文件！</li></ol><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程:"></a>编译过程:</h3><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7i041ohinj.webp"                        alt="图片"                 ></p><h4 id="o文件的保存-解决第一个问题："><a href="#o文件的保存-解决第一个问题：" class="headerlink" title="(.o文件的保存)解决第一个问题："></a>(.o文件的保存)解决第一个问题：</h4><p>简单点可以：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br><span class="line"></span><br><span class="line">./entry.o : ./entry.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> ./entry.c -o ./entry.o</span><br><span class="line"></span><br><span class="line">./func/bar.o : ./func/bar.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> ./func/bar.c -o ./func/bar.o</span><br></pre></td></tr></table></figure><p>通过手动添加目标和依赖，我们实现了 <code>*.o</code> 文件的保存，同时还确保了源文件在更新后，只会在最小限度内重新编译 <code>*.o</code> 文件。现在我们可以利用符号 <code>%</code> 和自动变量，来让 <code>Makefile</code> 变得更加通用。首先聚焦于编译过程：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./entry.o : ./entry.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> ./entry.c -o ./entry.o</span><br><span class="line"></span><br><span class="line">./func/bar.o : ./func/bar.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> ./func/bar.c -o ./func/bar.o</span><br></pre></td></tr></table></figure><p>上下比较 <code>./entry.o</code> 和 <code>./func/bar.o</code> 的目标依赖及执行，可以发现新添加的、用于生成 <code>*.o</code> 文件的目标和依赖，有着相同的书写模式，这意味着存在通用的写法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.1serq3nn73.webp"                        alt="图片"                 ></p><p>这里我们用上了 <code>%</code> ，它的作用有些难以用语言概括，上述例子中， <code>%.o</code> 的作用是匹配所有以 <code>.o</code> 结尾的目标；而后面的 <code>%.c</code> 中 <code>%</code> 的作用，则是将 <code>%.o</code> 中 <code>%</code> 的内容原封不动的挪过来用。</p><p>更具体地例子是，<code>%.o</code> 可能匹配到目标 <code>./entry.o</code> 或 <code>./func/bar.o</code>，这样 <code>%</code> 的内容就会是 <code>./entry</code> 或 <code>./func/bar</code>，最后交给 <code>%.c</code> 时就变成了 <code>./entry.c</code> 或 <code>./func/bar.c</code>。</p><p>另外我们还使用到了自动变量 <code>$&lt; $@</code>，其中 <code>$&lt;</code> 指代依赖列表中的第一个依赖；而 <code>$@</code> 指代目标。注意自动变量与普通变量不同，它不使用小括号。</p><p>结合起来使用，我们就得到了通用的生成 <code>*.o</code> 文件的写法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="链接过程："><a href="#链接过程：" class="headerlink" title="链接过程："></a>链接过程：</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main : ./entry.o ./func/bar.o</span><br><span class="line">        gcc ./entry.o ./func/bar.o -o main</span><br></pre></td></tr></table></figure><p>我们不能通过wildcard函数来实现通用的写法，因为在最开始我们是无法匹配到 <code>*.o</code> 文件的，因为起初我们只有 <code>*.c</code> 文件， <code>*.o</code> 文件是后来生成的。</p><h4 id="patsubst函数"><a href="#patsubst函数" class="headerlink" title="patsubst函数"></a>patsubst函数</h4><p>转换一下思路，我们在获取所有源文件后，直接将 <code>.c</code> 后缀替换为 <code>.o</code>，而patsubst 函数可以用于模式文本替换。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure><p>patsubst 函数的作用是匹配 <code>text</code> 文本中与 <code>pattern</code> 模式相同的部分，并将匹配内容替换为 <code>replacement</code>。于是链接步骤可以改写为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">        gcc <span class="variable">$(OBJS)</span> -o main</span><br></pre></td></tr></table></figure><p>最终的Makefile内容为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := .</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">        gcc <span class="variable">$(OBJS)</span> -o main</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h1 id="丰富完善Makefile的功能"><a href="#丰富完善Makefile的功能" class="headerlink" title="丰富完善Makefile的功能"></a>丰富完善Makefile的功能</h1><h2 id="指定-o文件的输出路径"><a href="#指定-o文件的输出路径" class="headerlink" title="指定*.o文件的输出路径"></a>指定*.o文件的输出路径</h2><p>我们想要将 <code>*.o</code> 文件保存至指定目录，与源文件和头文件区分开：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := ./</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,<span class="variable">$(OUTPUT)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">        gcc <span class="variable">$(OBJS)</span> -o main</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.o : %.c</span><br><span class="line">        mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">        gcc -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>上述Makefile中使用了dir函数</p><p><code>mkdir -p $(dir $@)</code>中 <code>$@</code>相当于目标 <code>$(OUTPUT)/%.o</code>dir函数取得其路径，mkdir创建需要的目录。</p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -r <span class="variable">$(OUTPUT)</span></span><br></pre></td></tr></table></figure><p>使用 <code>.PHONY</code>声明一个伪目标 <code>clean</code>使用的时候输入 <code>make clean</code>就会执行 <code>clean：</code>之后的命令</p><h2 id="简化终端输出"><a href="#简化终端输出" class="headerlink" title="简化终端输出"></a>简化终端输出</h2><p>我们常通过 <code>@</code> 符号，来禁止 Makefile 将执行的命令输出至终端上：</p><p>比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(OUTPUT)</span>/%.o : %.c</span><br><span class="line">        mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">        @gcc -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>执行 <code>make</code>之后 <code>gcc -c $(INCS) $&lt; -o $@</code>命令就不会在终端输出</p><p>同时我们也可以使用echo命令来拟定自己的输出信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r <span class="variable">$(OUTPUT)</span></span><br><span class="line">        @echo Complete!</span><br></pre></td></tr></table></figure><h2 id="自动生成依赖（解决第二个问题）"><a href="#自动生成依赖（解决第二个问题）" class="headerlink" title="自动生成依赖（解决第二个问题）"></a>自动生成依赖（解决第二个问题）</h2><p>我们要将头文件一同加入到 *.o 文件的依赖中，从而解决修改头文件后，包含该头文件的源文件不会重新编译的问题。</p><p>仅需在编译时指定 <code>-MMD</code> 选项，就能得到记录有依赖关系的 *.d 文件。</p><p><code>-MMD</code> 选项包含两个动作，一是生成依赖关系，二是保存依赖关系到 *.d 文件。与其类似的选项还有 <code>-MD</code>，其作用与 <code>-MMD</code> 相同，差别在于 <code>-MD</code> 选项会将系统头文件一同添加到依赖关系中。</p><p>另外我们还可以指定 <code>-MP</code> 选项，这会为每个依赖添加一个没有任何依赖的伪目标。<code>-MP</code> 选项生成的伪目标，可以有效避免删除头文件时，Makefile 因找不到目标来更新依赖所报的错误。</p><p>最终的Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SUBDIR := ./</span><br><span class="line">SUBDIR += ./func</span><br><span class="line"></span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,<span class="variable">$(OUTPUT)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">        @echo linking...</span><br><span class="line">        @gcc <span class="variable">$(OBJS)</span> -o main</span><br><span class="line">        @echo Complete!</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.o : %.c</span><br><span class="line">        @echo compile <span class="variable">$&lt;</span>...</span><br><span class="line">        @mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">        @gcc -MMD -MP -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r <span class="variable">$(OUTPUT)</span></span><br><span class="line">        @echo Complete!</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><p>最后一行的 <code>include</code> 用于将指定文件的内容插入到当前文本中。初次编译，或者 make clean 后再次编译时，*.d 文件是不存在的，这通常会导致 include 操作报错。所以我们在 <code>include</code> 前加了 <code>-</code> 符号，其作用是指示 make 在 include 操作出错时忽略这个错误，不输出任何错误信息并继续执行接下来的操作。</p><h1 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ROOT := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">SUBDIR := <span class="variable">$(ROOT)</span></span><br><span class="line">SUBDIR += <span class="variable">$(ROOT)</span>/func</span><br><span class="line"></span><br><span class="line">TARGET := main</span><br><span class="line">OUTPUT := ./output</span><br><span class="line"></span><br><span class="line">INCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,-I<span class="variable">$(dir)</span>)</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(ROOT)</span>/%.c,<span class="variable">$(OUTPUT)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line">DEPS := <span class="variable">$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$(OBJS)</span>)</span></span><br><span class="line"></span><br><span class="line">main : <span class="variable">$(OBJS)</span></span><br><span class="line">        @echo linking...</span><br><span class="line">        @gcc <span class="variable">$(OBJS)</span> -o main</span><br><span class="line">        @echo complete!</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>/%.o : %.c</span><br><span class="line">        @echo compile <span class="variable">$&lt;</span>...</span><br><span class="line">        @mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">        @gcc -MMD -MP -c <span class="variable">$(INCS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        @echo try to clean...</span><br><span class="line">        @rm -r <span class="variable">$(OUTPUT)</span></span><br><span class="line">        @echo complete!</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a class="link"   href="https://zhuanlan.zhihu.com/p/618350718" >写给初学者的makefile入门指南<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从代码到可执行文件需要预处理，编译，汇编和链接这几个步骤。&lt;/p&gt;
&lt;p&gt;而一个项目有多个源文件，如果只修改一个，就对所有源文件重新执行编译</summary>
      
    
    
    
    <category term="makefile" scheme="https://zhaozhan.site/categories/makefile/"/>
    
    
    <category term="makefile" scheme="https://zhaozhan.site/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>git问题记录</title>
    <link href="https://zhaozhan.site/2024/02/19/git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhaozhan.site/2024/02/19/git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2024-02-19T09:50:29.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git相关问题记录"><a href="#git相关问题记录" class="headerlink" title="git相关问题记录"></a>git相关问题记录</h1><ol><li><h2 id="ssl证书问题"><a href="#ssl证书问题" class="headerlink" title="ssl证书问题"></a>ssl证书问题</h2></li></ol><p>问题描述：</p><p>在用steam++的host代理模式时，使用git clone时出现ssl证书的问题如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;meta-api&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/dineshdixitgit/meta-api.git/&#x27;: SSL certificate problem: unable to get local issuer certificate</span><br></pre></td></tr></table></figure><p>问题解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看git相关配置</span><br><span class="line">git config -l --show-origin</span><br><span class="line">//将github desktop使用windows证书存储</span><br><span class="line">git config --global http.sslBackend schannel</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://github.com/desktop/desktop/issues/9293" >参考链接<i class="fas fa-external-link-alt"></i></a></p><ol start="2"><li><h2 id="https代理问题"><a href="#https代理问题" class="headerlink" title="https代理问题"></a>https代理问题</h2></li></ol><p>问题描述：</p><p>使用clash梯子时，git还是没有走梯子这个代理，所以git使用https方式clone时还是超时报错，默认从443端口访问，可以配置代理到7890可代理端口上</p><p>问题解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line">git config --global https.proxy 127.0.0.1:7890</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://blog.csdn.net/zpf1813763637/article/details/128340109" >参考链接<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li><h2 id="ssh代理问题"><a href="#ssh代理问题" class="headerlink" title="ssh代理问题"></a>ssh代理问题</h2></li></ol><p>问题描述：</p><p>使用clash梯子时，ssh并没有走梯子这个代理，所以还是连不到github，默认从22端口访问，可以将配置代理到443端口，走“问题2”的流程</p><p>问题解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在.ssh下创建config文件，填写以下内容：（若该文件已存在可直接在后边加上以下几行）</span><br><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://gist.github.com/Tamal/1cc77f88ef3e900aeae65f0e5e504794" >参考链接<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>注:上述代理需要手动配置的原因猜测是因为先安装配置了clash,后又安装了git,导致git的命令并没有走代理</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git相关问题记录&quot;&gt;&lt;a href=&quot;#git相关问题记录&quot; class=&quot;headerlink&quot; title=&quot;git相关问题记录&quot;&gt;&lt;/a&gt;git相关问题记录&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;ssl证书问题&quot;&gt;&lt;a href=&quot;#ssl证书问题&quot; </summary>
      
    
    
    
    <category term="git" scheme="https://zhaozhan.site/categories/git/"/>
    
    
    <category term="git" scheme="https://zhaozhan.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>完整git开发规范</title>
    <link href="https://zhaozhan.site/2024/02/19/%E5%AE%8C%E6%95%B4git%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://zhaozhan.site/2024/02/19/%E5%AE%8C%E6%95%B4git%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2024-02-19T09:49:04.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整git开发规范"><a href="#完整git开发规范" class="headerlink" title="完整git开发规范"></a>完整git开发规范</h1><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.4qr1tlkvw2.webp"                        alt="图片"                 ></p><ol><li><strong>master</strong>主分支,用于生产环境的主分支</li><li><strong>test</strong>分支,用于测试环境分支,一般可以自动CICD</li><li><strong>release</strong>分支,用于生产环境分支,只能通过master合并进入</li><li>fix&#x2F;* 分支,用于修补线上bug分支</li><li>feat&#x2F;* 分支,用于开发功能分支</li><li>refactor&#x2F;* 分支,用于重构代码</li><li><strong>禁止使用姓名缩写命名分支</strong></li></ol><h2 id="三大环境"><a href="#三大环境" class="headerlink" title="三大环境"></a>三大环境</h2><ol><li><p>生产环境</p><blockquote><p>用于部署成品的环境,master分支</p></blockquote></li><li><p>测试环境</p><blockquote><p>用于部署测试,test分支</p></blockquote></li><li><p>开发环境</p><blockquote><p>用于本地进行测试</p></blockquote></li></ol><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ol><li>git clone remote-url 克隆仓库</li><li>拉取最新代码<ol><li>git fetch origin master:master 不在master</li><li>git pull origin master 在master</li></ol></li><li>开发<ol><li><p>创建新分支</p><ol><li>git checkout -b feat&#x2F;xxx master 开发新功能</li><li>git checkout -b fix&#x2F;xxx master 修补bug</li><li>git checkout -b refactor&#x2F;xxx master 重构</li></ol></li><li><p>推送新分支</p><ol><li>git push origin xxx&#x2F;xxx</li></ol></li><li><p>合并到test分支</p><blockquote><p>前提是在开发环境测试没有问题</p></blockquote><ol><li><p>git fetch origin test:test</p></li><li><p>git checkout test</p></li><li><p>git merge xxx&#x2F;xxx(自己的分支)</p><blockquote><p>没有冲突</p></blockquote><ol><li>git push 推送分支</li></ol><blockquote><p>产生冲突</p></blockquote><ol><li>git checkout -b merge&#x2F;xxx test</li><li>git merge xxx&#x2F;xxx</li><li>解决冲突</li><li>git push origin xxx&#x2F;xxx</li><li>继续向test合并</li></ol></li></ol></li></ol></li><li>提出master的merge request(在gitlab中)</li></ol><blockquote><p>前提是在测试环境没有问题</p></blockquote><pre><code>- 产生冲突和test解决方式类似- review没有问题,合并分支到master,结束开发- review出问题1. 继续修改代码,解决问题再次请求合并</code></pre><ol start="4"><li><p>开发完毕,删除分支</p><ol><li>git push origin :xxx(远程分支名字)</li><li>git branch -d xxx(本地分支名字)</li></ol></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>提交merge request前<strong>必须经过测试环境检验</strong></li><li>test分支代码<strong>不能</strong>合并到master分支</li><li>test分支可以直接合并,master分支必须经过审核</li><li><strong>不要在test分支直接进行开发!</strong></li><li><strong>禁止使用姓名缩写命名分支</strong></li><li><strong>一旦分支合并入</strong> <strong>master</strong> <strong>,请删除分支,避免分支上二次开发</strong></li></ol><h2 id="远程分支跟踪"><a href="#远程分支跟踪" class="headerlink" title="远程分支跟踪"></a>远程分支跟踪</h2><ol><li>远程没有分支，本地也没有分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test  //创建并切换到新分支</span><br><span class="line">git push --set-upstream origin test  //推送到远程分支，并且跟踪远程分支</span><br></pre></td></tr></table></figure><ol start="2"><li>远程已经存在分支，本地不存在对应分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newtest origin/test</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li><code>type(scope) : subject</code></li></ul><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li>feat: 新特性或功能</li><li>fix: 缺陷修复</li><li>docs: 文档更新</li><li>style: 代码风格或者组件样式更新</li><li>refactor: 代码重构，不引入新功能和缺陷修复</li><li>perf: 性能优化</li><li>test: 单元测试</li><li>chore: 其他不修改 src 或测试文件的提交</li></ul><h4 id="scope-optional"><a href="#scope-optional" class="headerlink" title="scope(optional)"></a>scope(optional)</h4><ul><li>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</li></ul><h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><ul><li>简易描述该commit做了什么</li></ul><h2 id="MR规范"><a href="#MR规范" class="headerlink" title="MR规范"></a>MR规范</h2><ul><li>在仓库提交mr时候,应该注明修改或者添加了什么功能(相当于提交的总结,需要必commit message详细)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">1. fix:删除了审核的部分</span><br><span class="line">2. feat:完善了测试环境自动推送脚本</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完整git开发规范&quot;&gt;&lt;a href=&quot;#完整git开发规范&quot; class=&quot;headerlink&quot; title=&quot;完整git开发规范&quot;&gt;&lt;/a&gt;完整git开发规范&lt;/h1&gt;&lt;h2 id=&quot;分支策略&quot;&gt;&lt;a href=&quot;#分支策略&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="git" scheme="https://zhaozhan.site/categories/git/"/>
    
    
    <category term="git" scheme="https://zhaozhan.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git基础</title>
    <link href="https://zhaozhan.site/2024/02/19/git%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhaozhan.site/2024/02/19/git%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-19T09:47:24.000Z</published>
    <updated>2024-02-19T10:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>网址<a class="link"   href="https://git-scm.com/downloads" >https://git-scm.com/downloads<i class="fas fa-external-link-alt"></i></a>上安装</p><p>安装之后要设置自身全局配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加文件到git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>可以将上边的添加和提交和在一个命令中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="comment">#or git commit -am &quot;message&quot;</span></span><br><span class="line"><span class="comment">#注意：新增文件没有被commit</span></span><br></pre></td></tr></table></figure><p>修改最近一次提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>查看工作区状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看修改的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>查看提交历史，可以得知提交ID，即commit_id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>HEAD指向的是当前的版本，使用命令指向历史的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line"><span class="comment">#根据commit_id回退到指定版本</span></span><br><span class="line">git reset HEAD^</span><br><span class="line"><span class="comment">#将版本库回退一个版本，一个^一个版本</span></span><br><span class="line">git reset HEAD~n</span><br><span class="line"><span class="comment">#将版本库回退n个版本</span></span><br></pre></td></tr></table></figure><p>reset命令中有三个参数</p><ul><li>soft：软回退表示将本地版本库的头指针重置到指定的版本，且这次提交后的所有变更移动到暂存区</li><li>默认mixed：将本地版本库的头指针重置到指定的版本，且重置暂存区，所有变更移动到工作区</li><li>hard：将本地版本库的头指针重置到指定的版本，重置暂存区和工作区</li></ul><blockquote><p>此外：git reset HEAD filename 回退文件，将文件从暂存区回退到工作区，不能使用参数</p></blockquote><h4 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h4><p>重返未来则用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line"><span class="comment">#查看所有分支的操作记录之后使用git reset --hard commit_id命令回到原来的版本</span></span><br></pre></td></tr></table></figure><h3 id="Git-stash用法"><a href="#Git-stash用法" class="headerlink" title="Git stash用法"></a>Git stash用法</h3><p>Git stash用于将未提交的修改保存起来，用于后续恢复当前工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git stash save <span class="string">&quot;stash_name&quot;</span></span><br><span class="line"><span class="comment">#给每一个stash加一个message，用于记录版本</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="comment">#or git stash apply</span></span><br><span class="line"><span class="comment">#恢复最新缓存的工作目录（第一个），并删除缓存堆栈中的哪个stash（pop删除但是apply不删除）</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment">#查看所有的stash，在使用git stash之前使用，默认是第一个</span></span><br><span class="line">git stash drop</span><br><span class="line"><span class="comment">#移除最新的stash，后边也可以跟指定的stash的名字</span></span><br></pre></td></tr></table></figure><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区git add到暂存区，然后git commit到本地仓库</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>只有git add之后才能git commit到本地仓库</p><p>查看工作区和版本库里最新版本的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD --&lt;file&gt;</span><br></pre></td></tr></table></figure><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>场景1：当改乱工作区的文件内容后，要丢弃修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --file</span><br></pre></td></tr></table></figure><p>场景2：如果已经添加到了暂存区要丢弃修改，先：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>在按场景1操作。</p><p>场景3：提交到了版本库，参考版本回退</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>先rm file删除工作区文件，在使用命令删除本地仓库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br><span class="line">git commit -m &quot;remove file&quot;</span><br></pre></td></tr></table></figure><p>如果删错了，版本库中还有，可以一键还原</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br><span class="line"><span class="comment">#从版本库中拉取</span></span><br><span class="line">git checkout --hard HEAD</span><br><span class="line"><span class="comment">#从版本库中拉取，撤销所有的更改</span></span><br></pre></td></tr></table></figure><p>git checkout其实是用版本库里的版本替代工作区的版本，无论修改还是删除都可以一键还原</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>首先创建ssh key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example&quot;</span><br></pre></td></tr></table></figure><p>在用户主目录里找到.ssh目录，id_rsa.pub是公钥，将里边的ssh复制，在GitHub上打开Account settings的“SSH Key“页面</p><p>然后将本地库和远程库关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure><p>上述命令中origin是指定的远程库名称</p><p>然后是将本地库的代码推送到远程库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>第一次要有-u,上述的master为分支的名称，首次会发生警告</p><p>查看远程库信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h3 id="从远端库克隆"><a href="#从远端库克隆" class="headerlink" title="从远端库克隆"></a>从远端库克隆</h3><p>与远程库建立关联后可以直接git clone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure><p>也可以使用https协议</p><p>如果要克隆gitlab中的项目，要输入username和password登录，GIT_TERMINAL_PROMPT控制是否会出现登录界面</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>切回dev分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br></pre></td></tr></table></figure><p>强行删除分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature-vulcan</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>查看远程库信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#将本地的master分支推送到origin主机的master分支，如果master不存在则会被新建</span></span><br><span class="line">git push origin :master</span><br><span class="line"><span class="comment">#等同于git push origin --delete master，表示删除指定的远程分支</span></span><br><span class="line">git push origin</span><br><span class="line"><span class="comment">#如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可省略</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment">#如果当前分支和多个主机存在追踪关系，可以使用使用git push -u origin master指定一个默认主机，之后就可以直接使用git push</span></span><br></pre></td></tr></table></figure><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:username/reporstoryname.git</span><br></pre></td></tr></table></figure><p>注意clone的时候只能clone到main这一个分支</p><p>clone其他分支时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>当与他人的合并产生冲突时先git pull</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line">git pull origin master:<span class="built_in">test</span></span><br><span class="line"><span class="comment">#将远程的master分支和本地的test分支合并</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment">#默认和当前分支合并</span></span><br></pre></td></tr></table></figure><p>解决冲突后再推送</p><p>如果git pull还是失败，那么因为本地dev和远程的origin&#x2F;dev未建立链接，应设置链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/dev dev</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>rebase操作可以把本地未push的分叉提交历史整理成直线</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>切换到本分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>git tag 可以查看到所有标签</p><p>如果要打历史的标签可以先查找历史版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>上边–pretty&#x3D;oneline表示每个版本一行输出；–abbrev-commit表示提交号只显示前几位,找到对应的commit id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>若要查看标签信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.9</span><br></pre></td></tr></table></figure><p>还可以给标签添加信息说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>删除标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0</span><br></pre></td></tr></table></figure><p>将标签推送到远程库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>删除远程库的标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.9</span><br><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h2&gt;&lt;p&gt;网址&lt;a class=&quot;link&quot;   href=&quot;https://git-scm.com/downloads&quot; &gt;</summary>
      
    
    
    
    <category term="git" scheme="https://zhaozhan.site/categories/git/"/>
    
    
    <category term="git" scheme="https://zhaozhan.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>go语言进阶</title>
    <link href="https://zhaozhan.site/2024/02/19/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/"/>
    <id>https://zhaozhan.site/2024/02/19/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/</id>
    <published>2024-02-19T08:41:49.000Z</published>
    <updated>2024-02-21T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1></li></ol><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><blockquote><p>注意：一个包对应一个目录，一个目录下不同文件之间可以相互公开，只有不同的包之间需要大写使其公开。</p></blockquote><p>使用import之后编译运行一个文件就会连带着编译其import的包</p><h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>一个目录包括三个子目录</p><ul><li>src，不同的包的源代码</li><li>pkg，编译后的类库</li><li>bin，编译后的可执行程序</li></ul><p><code>go install</code> 命令将编译之后的结果文件：.a应用包或可执行文件导入到pkg或bin中</p><p><code>go get</code> 命令将源码直接导入src中然后执行 <code>go install</code></p><h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><p>gopath改进之后通过go.mod文件进行包的管理</p><p>通过命令 <code>go mod init [module name]</code> 生成go.mod文件</p><p>go.mod文件样例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module name</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.20</span></span><br><span class="line">require github.com/longjoy/micro-<span class="keyword">go</span>-book v0<span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>go mod tidy</code>命令进行依赖的更新</p><p>最终下载的第三方库保存在GOMODCACHE中，即GOPATH&#x2F;pkg&#x2F;mod中</p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.839rn80zjd.webp"                        alt="图片"                 ></p><ol start="2"><li><h1 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h1></li></ol><blockquote><p>一般不会自己写反射代码，理解原理即可</p></blockquote><p>提供运行时对代码的访问和修改的能力</p><p>两个概念</p><ul><li>Type：主要表示被反射变量的类型信息。</li><li>Value：表示被反射变量的类型信息</li></ul><p>go语言反射的实现主要位于reflect包中</p><h2 id="reflect-Type类型对象"><a href="#reflect-Type类型对象" class="headerlink" title="reflect.Type类型对象"></a>reflect.Type类型对象</h2><p>通过 <code>typeofname := reflect.Typeof(type name)</code>方法获取一个变量的类型信息，存到一个reflect.Type的类型的变量中。</p><p>通过typeofname.kind()获得type name的种类（struct 等等）而typeofname是指哪个包里定义的类型packagename.typename</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kind表示类型所表示的特定类型。</span></span><br><span class="line"><span class="comment">// 零类型不是有效类型。</span></span><br><span class="line"><span class="keyword">type</span> Kind uintconst (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span></span><br><span class="line">    Bool</span><br><span class="line">    Int</span><br><span class="line">    Int8</span><br><span class="line">    Int16</span><br><span class="line">    Int32</span><br><span class="line">    Int64</span><br><span class="line">    Uint</span><br><span class="line">    Uint8</span><br><span class="line">    Uint16</span><br><span class="line">    Uint32</span><br><span class="line">    Uint64</span><br><span class="line">    Uintptr</span><br><span class="line">    Float32</span><br><span class="line">    Float64</span><br><span class="line">    Complex64</span><br><span class="line">    Complex128</span><br><span class="line">    Array</span><br><span class="line">    Chan</span><br><span class="line">    Func</span><br><span class="line">    Interface</span><br><span class="line">    Map</span><br><span class="line">    Ptr</span><br><span class="line">    Slice</span><br><span class="line">    String</span><br><span class="line">    Struct</span><br><span class="line">    UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="类型对象reflect-StructField和reflect-Method"><a href="#类型对象reflect-StructField和reflect-Method" class="headerlink" title="类型对象reflect.StructField和reflect.Method"></a>类型对象reflect.StructField和reflect.Method</h3><h4 id="StructField"><a href="#StructField" class="headerlink" title="StructField"></a>StructField</h4><p>reflect中存在structfield类型用于存储：结构体内字段的类型信息</p><p>以上述通过typeof(type name)方法获得的一个结构体类型对象为接收器可以使用以下三个方法获得该结构体对象下属的字段的structfield类型信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个结构体内的字段数量</span></span><br><span class="line">NumField() <span class="type">int</span></span><br><span class="line"><span class="comment">//根据index获取结构体内的成员字段类型对象</span></span><br><span class="line">Field(i <span class="type">int</span>) StructField</span><br><span class="line"><span class="comment">//根据字段名获取结构体内的成员字段类型对象</span></span><br><span class="line">FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><p>StructField中的内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//成员字段名称</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    <span class="comment">//成员字段Type,reflect.Type类型</span></span><br><span class="line">    Type Type</span><br><span class="line">    <span class="comment">//Tag,主要描述字段的额外信息，如json序列化和对象映射的时候使用</span></span><br><span class="line">    Tag StructTag</span><br><span class="line">    <span class="comment">//字段偏移</span></span><br><span class="line">    Offset <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">//成员字段的Index</span></span><br><span class="line">    Index []<span class="type">int</span></span><br><span class="line">    <span class="comment">//成员字段是否公开</span></span><br><span class="line">    Anonymous <span class="type">bool</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>reflect中还存在Method类型用于存储：接口下方法的方法类型对象</p><p>go语言中可以声明一个接口变量，并赋值以接收器：<code>var person Person = &amp;Hero&#123;&#125;</code>,其中Person是一个接口，Hero是一个结构体。</p><p>通过相同的方法 <code>typeOfPerson := reflect.Typeof(person)</code>可以获得一个接口Person的类型对象。</p><p>而以接口类型对象为接收器存在以下方法来获取Method类型对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据index查找方法</span></span><br><span class="line">Method(<span class="type">int</span>) Method</span><br><span class="line"><span class="comment">//根据方法名查找方法</span></span><br><span class="line">MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line"><span class="comment">//获取类型中的公开的方法数量</span></span><br><span class="line">NumMethod() <span class="type">int</span></span><br></pre></td></tr></table></figure><p>Method内的基本信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Method <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//方法名</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    <span class="comment">//方法类型</span></span><br><span class="line">    Type Type</span><br><span class="line">    <span class="comment">//反射对象，可用于调用方法</span></span><br><span class="line">    Func Value</span><br><span class="line">    <span class="comment">//方法的index</span></span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Method.Type为func(接收器,剩余的原方法参数)</p><h2 id="reflect-Value反射值对象"><a href="#reflect-Value反射值对象" class="headerlink" title="reflect.Value反射值对象"></a>reflect.Value反射值对象</h2><p>使用上述的Type类型对象，我们只能查看类型信息，不能对变量的值进行查看和修改，所以有了reflect.Value反射值对象。</p><p>可以通过reflect.ValueOf获取反射变量的信息Value，通过Value对变量的值进行查看和修改。</p><h3 id="获取变量值"><a href="#获取变量值" class="headerlink" title="获取变量值"></a>获取变量值</h3><p>通过Value.Interface()方法获取变量的值</p><p>可以使用reflect.New(类型对象)创建一个相同类型的新变量，值以Value对象的形式返回。</p><h3 id="改变变量值"><a href="#改变变量值" class="headerlink" title="改变变量值"></a>改变变量值</h3><p>对变量的修改可以通过方法Value.Set方法实现</p><p>例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;小明&quot;</span></span><br><span class="line">valueOfName := reflect.ValueOf(&amp;name)</span><br><span class="line">valueOfName.Elem().Set(reflect.ValueOf(<span class="string">&quot;小红&quot;</span>))</span><br><span class="line">fmt.Println(name)</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于Value的值是原变量值的拷贝，即使ValueOf(&amp;name)，也只是指向name指针的拷贝，要寻址到原变量要使用#Elem方法。</p></blockquote><p>可以通过方法#CanAddr方法判断是否可以寻址</p><h3 id="结构体value"><a href="#结构体value" class="headerlink" title="结构体value"></a>结构体value</h3><p>对于结构体的反射值对象，可以通过Value.CanSet判断某字段是否公开可以改变，结构体的value同时也有类似type的一些方法：#NumField，#FieldByIndex，#FieldByName来获取字段的value</p><h3 id="反射接口方法调用"><a href="#反射接口方法调用" class="headerlink" title="反射接口方法调用"></a>反射接口方法调用</h3><p>使用函数 <code>func (v value) Call(in []value) []Value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明接口以及确定其接收器</span></span><br><span class="line"><span class="keyword">var</span> person Person = &amp;Hero&#123;</span><br><span class="line">    Name:<span class="string">&quot;小红&quot;</span>,</span><br><span class="line">    Speed:<span class="string">&quot;100&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">valueOfPerson := reflect.ValueOf(person)</span><br><span class="line"><span class="comment">//获取sayHello函数</span></span><br><span class="line">sayHelloMethod := valueOfPerson.MethodByName(<span class="string">&quot;sayHello&quot;</span>)</span><br><span class="line"><span class="comment">//使用#Call方法调用</span></span><br><span class="line">sayHelloMethod.Call([]reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;小张&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure><p>也可以使用上边type中的Method.func调用，但要将接收器作为第一个参数传入</p><ol start="3"><li><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1></li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li>并发：同一时间段内，多条指令在CPU上同时执行</li><li>并行：同一时刻上，多条指令在CPU上同时执行</li></ul><h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><p>go语言实现两种并发模型</p><ul><li>线程与锁并发模型：依赖于共享内存，程序出错不易排查</li><li>CSP（通信顺序进程模型）：有两个关键概念<ul><li>并发实体：即执行线程，他们之间相互独立并发执行</li><li>通道：并发实体之间使用通道发送信息</li></ul></li></ul><p>极易导致死锁</p><h2 id="常见线程模型"><a href="#常见线程模型" class="headerlink" title="常见线程模型"></a>常见线程模型</h2><p>线程是操作系统能够调度的最小单位分为用户线程和内核线程</p><ul><li>用户线程：由用户空间的代码创建、管理和销毁，调度由用户空间的线程库完成</li><li>内核线程：由操作系统管理和调度，线程切换需要cpu切换为内核态</li></ul><p>用户线程无法被操作系统感知，用户线程所属的进程或者内核线程才能被操作系统直接调度。</p><ol><li><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3></li></ol><p>一个进程包含多个用户线程，对应一个内核线程</p><p>缺点：一个用户线程阻塞导致整个进程失去时间片</p><ol start="2"><li><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3></li></ol><p>每个用户线程对应一个内核线程</p><p>缺点：线程切换从用户态到内核态资源消耗大</p><ol start="3"><li><h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3></li></ol><p>上述两个模型相结合：一个进程对应多个内核线程，由进程中的调度器决定进程内的线程如何与申请的内核线程相对应。</p><h2 id="GMP线程模型"><a href="#GMP线程模型" class="headerlink" title="GMP线程模型"></a>GMP线程模型</h2><p>go语言中的MPG线程模型对两级线程模型进行改进：</p><ul><li>M：Machine，一个Machine对应一个内核线程，相当于内核线程在go语言进程中的映射</li><li>P：Processor，go代码片段执行所需的上下文环境，用户代码逻辑处理器</li><li>G：Goroutine，go代码片段的封装，是一种轻量级的用户线程</li></ul><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.7p3bx3vi6e.webp"                        alt="图片"                 ></p><p><img                         lazyload                       alt="image"                       data-src="https://extious.github.io/picx-images-hosting/%E5%9B%BE%E7%89%87.1vydnt930r.webp"                        alt="图片"                 ></p><p>如上图：M，P共同构成了一个基本的运行环境，此时G0中的代码处于运行的状态，右边G队列处于待执行的状态。</p><p>当没有足够的M来和P组合为G提供运行环境时，Go语言会创建新的M，在很多时候M的数量可能比P多。在单个Go语言进程中，P的最大数量决定了程序的并发规模，且P的最大数量由程序决定，可以通过修改环境变量GOMAXPROCS和调用函数runtime.GOMAXPROCS来设定P的最大值。</p><ol start="4"><li><h1 id="并发实践"><a href="#并发实践" class="headerlink" title="并发实践"></a>并发实践</h1></li></ol><h2 id="协程goroutine"><a href="#协程goroutine" class="headerlink" title="协程goroutine"></a>协程goroutine</h2><p>goroutine是go语言中的轻量级进程，在运行的时候由runtine管理，我们编写main函数也是运行在goroutine之上，可以通过 <code>go 表达式语句</code> 来启动一个新的goroutine</p><p>表达式语句可以是内建函数，也可以是自定义的方法和函数（命名或匿名都可）</p><blockquote><p>注意：go语言不同的goroutine间的代码次序并不代表真正的执行顺序（不清楚真正的调度顺序），主goroutine结束，其创建的goroutine如果还没有执行那么会被销毁。</p></blockquote><h3 id="对比OS线程"><a href="#对比OS线程" class="headerlink" title="对比OS线程"></a>对比OS线程</h3><ul><li>os线程：固定栈内存：2MB</li><li>goroutine：栈内存不固定，从2KB到1GB</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, v) <span class="comment">//用的是协程外面的全局变量v。输出4 4 4 4</span></span><br><span class="line">                &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">        fmt.Println()</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, value) <span class="comment">//输出1 4 2 3</span></span><br><span class="line">                &#125;(v) <span class="comment">//把v的副本传到协程内部</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">        fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://zhuanlan.zhihu.com/p/597424646?utm_id=0" >goroutine协程关闭<i class="fas fa-external-link-alt"></i></a></p><h2 id="通道channel"><a href="#通道channel" class="headerlink" title="通道channel"></a>通道channel</h2><p>channel声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channelName <span class="keyword">chan</span> T    <span class="comment">//T为可传输数据类型</span></span><br><span class="line">channelName &lt;- val    <span class="comment">//将val的值传到channelName中</span></span><br><span class="line">val,ok := channel    <span class="comment">//ok检查channel是否关闭</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> T,sizeOfChan)    <span class="comment">//使用make对channel进行初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：创建channel时如果指定channel的长度，那么有缓冲区，缓冲区未满时不阻塞，如果没有指定长度，那么只会往里边写入一次之后就会阻塞</p></blockquote><p>【实例】不断从终端中获取数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInput</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> val := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;EOF&quot;</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Input is %s\n&quot;</span>,val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> printInput(ch)</span><br><span class="line">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan()&#123;</span><br><span class="line">        val := scanner.Text()</span><br><span class="line">        ch &lt;- val</span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">&quot;EOF&quot;</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;End the game!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>使用select可以从多个channel中读取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> val := &lt;- ch1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> val := &lt;- ch2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">2</span> * time.Second):    <span class="comment">//超时处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync同步包"><a href="#sync同步包" class="headerlink" title="sync同步包"></a>sync同步包</h2><h3 id="互斥锁：Mutex"><a href="#互斥锁：Mutex" class="headerlink" title="互斥锁：Mutex"></a>互斥锁：Mutex</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">lock.Lock()</span><br><span class="line">lock.Unlock()</span><br></pre></td></tr></table></figure><h3 id="读写锁：RWMutex"><a href="#读写锁：RWMutex" class="headerlink" title="读写锁：RWMutex"></a>读写锁：RWMutex</h3><p>接口：（允许多读单写，读写互斥）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br><span class="line"><span class="comment">//写解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br><span class="line"><span class="comment">//读加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br><span class="line"><span class="comment">//读解锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br></pre></td></tr></table></figure><h3 id="WaitGroup（并发等待组）"><a href="#WaitGroup（并发等待组）" class="headerlink" title="WaitGroup（并发等待组）"></a>WaitGroup（并发等待组）</h3><p>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加等待数量，传递负数表示任务减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add（delta <span class="type">int</span>）</span><br><span class="line"><span class="comment">//等待数量减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br><span class="line"><span class="comment">//使goroutine等待于此</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure><h3 id="map（并发安全字典）"><a href="#map（并发安全字典）" class="headerlink" title="map（并发安全字典）"></a>map（并发安全字典）</h3><p>原生的字典map多个goroutine同时添加key-value的时候可能会发生数据的丢失</p><p>go语言中有sync.Map提供以下接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据key获取存储值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;,ok <span class="type">bool</span>)</span><br><span class="line"><span class="comment">//设置key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//如果key存在则返回key对应的value，否则设置key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;,loaded <span class="type">bool</span>)</span><br><span class="line"><span class="comment">//删除一个key以及对应值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//无序遍历map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key,value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p>参考：<a class="link"   href="https://studygolang.com/pkgdoc" >go标准库中文文档<i class="fas fa-external-link-alt"></i></a></p><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>读文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">fileObj,err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"><span class="comment">//简单读文件</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>&#123;[]<span class="type">byte</span>,<span class="number">128</span>&#125;</span><br><span class="line">n,err := fileObj.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bufio读取文件(一行)</span></span><br><span class="line">reader := bufio.NewReader(fileObj)</span><br><span class="line">line,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">//Ioutil读文件（整个文件）</span></span><br><span class="line">ret,err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br></pre></td></tr></table></figure><p>写文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">fileObj,err := os.OpenFile(<span class="string">&quot;./log.txt&quot;</span>,os.O_APPEND|os.O_CREATE,<span class="number">0644</span>)</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"><span class="comment">//普通写入</span></span><br><span class="line">fileObj.Write([]<span class="type">byte</span>(<span class="string">&quot;xxx&quot;</span>))</span><br><span class="line">fileObj.WriteString(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="comment">//bufio写文件</span></span><br><span class="line">writer := bufio.NewWriter(fileObj)</span><br><span class="line">writer.WriteString(<span class="string">&quot;xxx&quot;</span>)<span class="comment">//写入缓存</span></span><br><span class="line">writer.Flush()<span class="comment">//写入文件</span></span><br><span class="line"><span class="comment">//ioutil写文件</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;./log.txt&quot;</span>,[]<span class="type">byte</span>(str),<span class="number">0666</span>)</span><br></pre></td></tr></table></figure><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()<span class="comment">//时间对象</span></span><br><span class="line">now.Year()</span><br><span class="line">now.Unix()<span class="comment">//时间戳格式</span></span><br><span class="line">nowTime := time.Unix(now,<span class="number">0</span>)<span class="comment">//将时间戳转化为时间对象</span></span><br><span class="line">now.Add(<span class="number">24</span> * time.Hour)<span class="comment">//加时间</span></span><br><span class="line">timer := time.Tick(time.Second)<span class="comment">//定时器，一直在变，一秒一算</span></span><br><span class="line">now.Format(<span class="string">&quot;2006-01-02&quot;</span>)<span class="comment">//时间对象格式化输出</span></span><br><span class="line">now.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>)</span><br><span class="line">timeObj := time.Parse(<span class="string">&quot;2006-01-02&quot;</span>,<span class="string">&quot;2004-01-01&quot;</span>)<span class="comment">//将字符串解析为时间对象</span></span><br><span class="line">time.Duration(<span class="number">100</span>)<span class="comment">//将100转化为100ns的时间间隔类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sub 时间相减</span></span><br><span class="line"><span class="comment">Before 判断时间前后</span></span><br><span class="line"><span class="comment">Equal 判断时间是否相等</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Strconv"><a href="#Strconv" class="headerlink" title="Strconv"></a>Strconv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串解析为10进制，64位数</span></span><br><span class="line">strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">strconv.Atoi(str)</span><br><span class="line"><span class="comment">//将数字转换为字符串</span></span><br><span class="line">strconv.Itoa(i)</span><br><span class="line"><span class="comment">//将字符串转化为bool</span></span><br><span class="line">strconv.ParseBool(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 包提供上下文机制在 goroutine 之间传递 deadline、取消信号（cancellation signals）或者其他请求相关的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">//返回值为管道，正常情况下阻塞，直到cancelfunc，chan关闭</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//查看deadline,通过withdeadline设置，若没设置则返回ok=false</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    <span class="comment">//chan关闭时会返回error，说明cancel原因</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    <span class="comment">//返回由WithValue关联到context的值。</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建根context"><a href="#创建根context" class="headerlink" title="创建根context"></a>创建根context</h3><p>根 context 不会被 cancel。这两个方法只能用在最外层代码中，比如 main 函数里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般使用 Background() 方法创建根 context。</span></span><br><span class="line">context.Background()</span><br><span class="line"><span class="comment">//TODO() 用于当前不确定使用何种 context，留待以后调整。</span></span><br><span class="line">context.TODO()</span><br></pre></td></tr></table></figure><h3 id="派生context"><a href="#派生context" class="headerlink" title="派生context"></a>派生context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span><span class="string">&quot;fmt&quot;</span><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepRandom_1</span><span class="params">(stopChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;This is sleep Random 1: %d\n&quot;</span>, i)</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;cancel sleep random 1&quot;</span>)</span><br><span class="line">            stopChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sleepRandom_2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;This is sleep Random 2: %d\n&quot;</span>, i)</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Why? %s\n&quot;</span>, ctx.Err())</span><br><span class="line">            fmt.Println(<span class="string">&quot;cancel sleep random 2&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctxParent, cancelParent := context.WithCancel(context.Background())</span><br><span class="line">    ctxChild, _ := context.WithCancel(ctxParent)</span><br><span class="line">    stopChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> sleepRandom_1(stopChan)</span><br><span class="line">    <span class="keyword">go</span> sleepRandom_2(ctxChild)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- stopChan:</span><br><span class="line">        fmt.Println(<span class="string">&quot;stopChan received&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cancelParent()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Continue...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h1 id=&quot;依赖管理&quot;&gt;&lt;a href=&quot;#依赖管理&quot; class=&quot;headerlink&quot; title=&quot;依赖管理&quot;&gt;&lt;/a&gt;依赖管理&lt;/h1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;包管理&quot;&gt;&lt;a href=&quot;#包管理&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="golang" scheme="https://zhaozhan.site/categories/golang/"/>
    
    
    <category term="golang" scheme="https://zhaozhan.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go语言基础</title>
    <link href="https://zhaozhan.site/2024/02/19/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhaozhan.site/2024/02/19/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-19T08:36:52.000Z</published>
    <updated>2024-02-19T08:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="Linux下go环境安装"><a href="#Linux下go环境安装" class="headerlink" title="Linux下go环境安装"></a>Linux下go环境安装</h2><p>在官网上安装源码.tar.gz文件</p><p>将文件解压到系统中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xzf go1.xx.xx.linux=amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>配置环境变量</p><p>在 ~&#x2F;.bashrc中添加以下几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin:<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><h2 id="go语言特性"><a href="#go语言特性" class="headerlink" title="go语言特性"></a>go语言特性</h2><p>静态编译型语言</p><ul><li>静态：强类型，在编译的时候就确定</li><li>编译型：相对于解释型少一个解释器，直接由源代码编译得到二进制程序</li></ul><h2 id="第一个go语言程序"><a href="#第一个go语言程序" class="headerlink" title="第一个go语言程序"></a>第一个go语言程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个可执行的 golang 程序必定具备一个 main 包，并在该 main 包下具有执行函数 main 的 go 文件</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HelloGo.go</span></span><br><span class="line"><span class="comment">// 基于图灵 API 一个简单的聊天机器人</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入相关依赖</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;bytes&quot;</span></span><br><span class="line"> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求体结构体</span></span><br><span class="line"><span class="keyword">type</span> requestBody <span class="keyword">struct</span> &#123;</span><br><span class="line"> Key <span class="type">string</span>  <span class="string">`json:&quot;key&quot;`</span></span><br><span class="line"> Info <span class="type">string</span>  <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line"> UserId <span class="type">string</span>  <span class="string">`json:&quot;userid&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 结果体结构体</span></span><br><span class="line"><span class="keyword">type</span> responseBody <span class="keyword">struct</span> &#123;</span><br><span class="line"> Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line"> Text <span class="type">string</span> <span class="string">`json:&quot;text&quot;`</span></span><br><span class="line"> List []<span class="type">string</span> <span class="string">`json:&quot;list&quot;`</span></span><br><span class="line"> Url <span class="type">string</span> <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求机器人</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(inputChan &lt;-<span class="keyword">chan</span> <span class="type">string</span>, userid <span class="type">string</span>)</span></span>  &#123;</span><br><span class="line"> <span class="keyword">for</span>&#123;</span><br><span class="line">  <span class="comment">// 从通道中接受输入</span></span><br><span class="line">  input := &lt;- inputChan</span><br><span class="line">  <span class="keyword">if</span> input == <span class="string">&quot;EOF&quot;</span>&#123;</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建请求体</span></span><br><span class="line">  reqData := &amp;requestBody&#123;</span><br><span class="line">   Key: <span class="string">&quot;792bcf45156d488c92e9d11da494b085&quot;</span>,</span><br><span class="line">   Info : input,</span><br><span class="line">   UserId: userid,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转义为 json</span></span><br><span class="line">  byteData,_ := json.Marshal(&amp;reqData)</span><br><span class="line">  <span class="comment">// 请求聊天机器人接口</span></span><br><span class="line">  req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">   <span class="string">&quot;http://www.tuling123.com/openapi/api&quot;</span>,</span><br><span class="line">   bytes.NewReader(byteData))</span><br><span class="line"> </span><br><span class="line">  req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>)</span><br><span class="line"> </span><br><span class="line">  client := http.Client&#123;&#125;</span><br><span class="line">  resp, err := client.Do(req)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Network Error!&quot;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 将结果从 json 中解析并输出到命令行</span></span><br><span class="line">   body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">   <span class="keyword">var</span> respData responseBody</span><br><span class="line">   json.Unmarshal(body, &amp;respData)</span><br><span class="line">   fmt.Println(<span class="string">&quot;AI: &quot;</span> + respData.Text)</span><br><span class="line">  &#125;</span><br><span class="line">  resp.Body.Close()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> input <span class="type">string</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;Enter &#x27;EOF&#x27; to shut down: &quot;</span>)</span><br><span class="line"> <span class="comment">// 创建通道</span></span><br><span class="line"> channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="comment">// main 结束时关闭通道</span></span><br><span class="line"> <span class="keyword">defer</span> <span class="built_in">close</span>(channel)</span><br><span class="line"> <span class="comment">// 启动 goroutine 运行机器人回答线程</span></span><br><span class="line"> <span class="keyword">go</span> process(channel, <span class="type">string</span>(rand.Int63()))</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="comment">// 从命令行中读取输入</span></span><br><span class="line">   fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;input)</span><br><span class="line">   <span class="comment">// 将输入放到通道中</span></span><br><span class="line">   channel &lt;- input</span><br><span class="line">   <span class="comment">// 结束程序</span></span><br><span class="line">   <span class="keyword">if</span> input == <span class="string">&quot;EOF&quot;</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bye!&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ol><li><code>go run</code>命令直接编译执行：<code>go run HelloGo.go</code></li><li><code>go build</code> 命令先编译得到可执行文件<ol><li><code>go build -o HelloGo HelloGo.go</code> 或者 <code>go build HelloGo.go</code> 会生成一个HelloGo可执行文件。</li></ol></li></ol><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="变量声明和初始化"><a href="#变量声明和初始化" class="headerlink" title="变量声明和初始化"></a>变量声明和初始化</h2><h3 id="基本样式"><a href="#基本样式" class="headerlink" title="基本样式"></a>基本样式</h3><ol><li><code>var name TYPE</code></li><li><code>var name TYPE = 表达式</code></li><li><code>var a = 100</code> 或 <code>b:= &quot;hello&quot;</code></li></ol><blockquote><p>注意：<code>:=</code> 不能用于全局变量的声明和初始化,同时其左值中的变量最少有一个变量必须是未定义过的变量</p></blockquote><h3 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h3><p>交换a,b的值可以使用 <code>a,b = b,a</code></p><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>函数使用多返回值时，使用 <code>a,_:=getName()</code> _为匿名变量，不占用命名空间和内存</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li>按长度：int8,int16,int32,int64</li><li>按有无符号：uint8,uint16,uint32,uint64</li></ul><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>两种：float32和float64</p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>true和fasle</p><blockquote><p>注意：bool与整型不能转换，bool型不能参与数值运算</p></blockquote><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>String</p><blockquote><p>注意遍历字符串的时候可以以byte和rune两种方式，具体参考<a class="link"   href="http://c.biancheng.net/view/18.html#:~:text=Go%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%EF%BC%88byte%E5%92%8Crune%EF%BC%89%201%20%E4%B8%80%E7%A7%8D%E6%98%AF%20uint8%20%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E5%8F%AB%20byte%20%E5%9E%8B%EF%BC%8C%E4%BB%A3%E8%A1%A8%E4%BA%86%20ASCII,UTF-8%20%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%BD%93%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E3%80%81%E6%97%A5%E6%96%87%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%A4%8D%E5%90%88%E5%AD%97%E7%AC%A6%E6%97%B6%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%20rune%20%E7%B1%BB%E5%9E%8B%E3%80%82%20rune%20%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E4%BA%8E%20int32%20%E7%B1%BB%E5%9E%8B%E3%80%82" >字符类型：byte和rune<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>默认for range遍历使用rune方式</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><ul><li>断言x不为nil且x为T类型</li><li>如果T不是接口类型，则该断言x为T类型</li><li>如果T类接口类型，则该断言x实现了T接口</li></ul><blockquote><p>直接赋值的方式，如果断言为true则返回该类型的值，如果断言为false则产生runtime panic；j这里赋值直接panic</p></blockquote><p>不过一般为了避免panic，通过使用ok的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">7</span></span><br><span class="line">    j, ok := x.(<span class="type">int32</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(reflect.TypeOf(j))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;x not type of int32&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种就是variable.(type)配合switch进行类型判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;x is type of int&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unknown type %T!\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><a class="link"   href="https://juejin.cn/post/7080938405449695268" >泛型参考链接<i class="fas fa-external-link-alt"></i></a></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>具体内容和C语言差不多，只不过限制了指针类型的偏移和运算能力，增加了自动垃圾回收机制</p><p>【实例】使用flag从命令行中读取参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//参数以此是命令行参数的名称，默认值，提示</span></span><br><span class="line">surname := flag.String(<span class="string">&quot;surname&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;您的姓&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> personalName <span class="type">string</span></span><br><span class="line">flag.StringVar(personalName,<span class="string">&quot;personalName&quot;</span>,<span class="string">&quot;小二&quot;</span>,<span class="string">&quot;您的名&quot;</span>)</span><br><span class="line">id := flag.Int(<span class="string">&quot;id&quot;</span>,<span class="number">0</span>,<span class="string">&quot;您的id&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Printf(<span class="string">&quot;I am %v %v,and my id is %v\n&quot;</span>,*surname,personalName,*id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行中输入 <code>go run Flag.go -surname=&quot;苍&quot; -personalName=&quot;小屋&quot; -id=100</code> 得到输出：<code>I am 苍 小屋，and my id is 100</code></p><p>Flag支持</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-id=<span class="number">100</span></span><br><span class="line">--id=<span class="number">100</span></span><br><span class="line">-id <span class="number">100</span></span><br><span class="line">--id <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="常量与类型别名"><a href="#常量与类型别名" class="headerlink" title="常量与类型别名"></a>常量与类型别名</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用const关键字</p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul><li>定义类型别名：<code>·type name = TYPE·</code></li><li>定义新类型：<code>·type name TYPE·</code></li></ul><h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li>If else条件语句注意与if匹配的”{“和if在同一行；else必须与上一个分支的”}”位于同一行</li><li>switch语句不需要用break，可以用fallthrough关键字连接两个case；可以对字符串和复杂表达式进行判断；可以写成if-else类型：switch后没有变量，case后接条件判断表达式。</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>只有一种for循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init;condition;end&#123;</span><br><span class="line">循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见容器"><a href="#常见容器" class="headerlink" title="常见容器"></a>常见容器</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明初始化的几种方式</p><p><code>var name [size]TYPE</code></p><p><code>name := [...]string&#123;&quot;xiaoming&quot;,&quot;xiaohong&quot;,&quot;xiaoli&quot;&#125;</code></p><p><code>name := new([size]TYPE)</code></p><p>使用指针操作数组时不支持偏移和运算。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="从原生数组中生成切片"><a href="#从原生数组中生成切片" class="headerlink" title="从原生数组中生成切片"></a>从原生数组中生成切片</h3><p><code>slice := source[begin:end]</code>包括begin不包括end；修改切片相当于修改数组</p><h3 id="动态创建切片"><a href="#动态创建切片" class="headerlink" title="动态创建切片"></a>动态创建切片</h3><p><code>make([]TYPE,size,cap)</code>得到的切片会被初始化为其类型的初始值</p><h3 id="声明新的切片"><a href="#声明新的切片" class="headerlink" title="声明新的切片"></a>声明新的切片</h3><p><code>var name []TYPE</code>相当于声明数组时没有设置大小</p><h3 id="向切片中添加元素"><a href="#向切片中添加元素" class="headerlink" title="向切片中添加元素"></a>向切片中添加元素</h3><p>使用append函数</p><p>size&lt;&#x3D;cap时：更新原数组</p><p>size&gt;cap时：申请新空间</p><blockquote><p>可以使用 <code>copy(destSli,srcSli []TYPE)</code> 复制切片</p></blockquote><h2 id="列表与字典"><a href="#列表与字典" class="headerlink" title="列表与字典"></a>列表与字典</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>双向有序链表，每个节点可以是不同的数据类型</p><p>引入container&#x2F;list包</p><p>初始化：<code>var name list.List</code> or <code>name := list.New()</code></p><p>对应函数：</p><ul><li>PushBack(element)</li><li>PushFront(element)</li><li>Remove(element)</li><li>头元素：Front()</li><li>下一个元素：Next()</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">classMates1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//添加映射关系</span></span><br><span class="line">classMates1[<span class="number">0</span>] = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="comment">//在声明的时候初始化</span></span><br><span class="line">classMates2 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&quot;小明&quot;</span>，</span><br><span class="line">    <span class="number">1</span>:<span class="string">&quot;小红&quot;</span>，</span><br><span class="line">    <span class="number">2</span>:<span class="string">&quot;小张&quot;</span>，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断map中某个键是否存在</p><p><code>value,ok := classmate2[1]</code> if 存在 then ok为true.</p><h2 id="容器遍历"><a href="#容器遍历" class="headerlink" title="容器遍历"></a>容器遍历</h2><p>使用for-range遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：遍历循环体中对k，v修改不会影响到原容器的内容</p></blockquote><h1 id="函数与接口"><a href="#函数与接口" class="headerlink" title="函数与接口"></a>函数与接口</h1><h2 id="函数的声明和参数传递"><a href="#函数的声明和参数传递" class="headerlink" title="函数的声明和参数传递"></a>函数的声明和参数传递</h2><p>具体样式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(params)</span></span>(<span class="keyword">return</span> params)&#123;</span><br><span class="line"> function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可返回多个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line">x,y=swap(x,y)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果函数需要在包外的代码使用，则函数名要大写</p></blockquote><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><p>匿名函数：初始化和调用一起</p><p>主要用于回调函数和闭包</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数作为参数传递，实现回调。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数类型</span></span><br><span class="line"><span class="keyword">type</span> cb <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testCallBack(<span class="number">1</span>, callBack)</span><br><span class="line">    testCallBack(<span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;我是回调，x：%d\n&quot;</span>, x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testCallBack</span><span class="params">(x <span class="type">int</span>, f cb)</span></span> &#123;</span><br><span class="line">    f(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callBack</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;我是回调，x：%d\n&quot;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>携带状态的函数叫做闭包，包的是函数和变量环境</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口声明和嵌套"><a href="#接口声明和嵌套" class="headerlink" title="接口声明和嵌套"></a>接口声明和嵌套</h2><p>接口：调用方和实现方约定的一种合作协议。调用者不关心接口的实现方式，实现者通过接口暴露自己的内在功能。每个接口有一个或多个方法</p><blockquote><p>注意：只有当接口名和方法名的首字母都为大写的时候，表示公开，包外可以被访问</p></blockquote><p>样式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfaceName <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(params)(<span class="keyword">return</span> params)</span><br><span class="line">    method2(params)(<span class="keyword">return</span> params)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是可以嵌套的</p><h2 id="函数体实现接口"><a href="#函数体实现接口" class="headerlink" title="函数体实现接口"></a>函数体实现接口</h2><p>go语言中的所有类型都可以实现接口</p><p>首先定义一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Print(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数定义为类型之后实现接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncCaller <span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="comment">//实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(funcCaller FuncCaller)</span></span> Print(p <span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">    <span class="comment">//调用函数本体</span></span><br><span class="line">    funcCaller(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> printer Printer</span><br><span class="line">    printer = FuncCaller(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">        fmt.Println(p)  </span><br><span class="line">    &#125;)</span><br><span class="line">    printer.Print(<span class="string">&quot;Golang is good!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h1><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>样式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span>&#123;</span><br><span class="line">    value1 valueType1</span><br><span class="line">    value2 valueType2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：结构体公开则其名首字母大写；字段公开则字段名首字母大写</p></blockquote><h2 id="结构体的实例化和初始化"><a href="#结构体的实例化和初始化" class="headerlink" title="结构体的实例化和初始化"></a>结构体的实例化和初始化</h2><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>声明实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 Person</span><br><span class="line">p1.Name = <span class="string">&quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure><p>函数实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2:= <span class="built_in">new</span>(Person)<span class="comment">//指针类型</span></span><br><span class="line">p2.Name = <span class="string">&quot;xiaohong&quot;</span></span><br></pre></td></tr></table></figure><p>取址实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;Person&#123;&#125;</span><br><span class="line">p3.Name = <span class="string">&quot;xiaozhang&quot;</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p4 := &amp;Person&#123;</span><br><span class="line">    Name:<span class="string">&quot;xiaowang&quot;</span>,</span><br><span class="line">    Birth:<span class="string">&quot;2004-01-01&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果所有字段都初始化，可以按顺序省略字段名</span></span><br></pre></td></tr></table></figure><h2 id="方法和接收器"><a href="#方法和接收器" class="headerlink" title="方法和接收器"></a>方法和接收器</h2><p>方法定义样式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recipient recipientType)</span></span> methodName(params)(<span class="keyword">return</span> params)&#123;</span><br><span class="line">function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：接收器最好选用指针类型</p></blockquote><h2 id="结构体实现接口"><a href="#结构体实现接口" class="headerlink" title="结构体实现接口"></a>结构体实现接口</h2><p>接口Cat,Dog定义+实现结构体CatDog定义+接口（方法）实现</p><p>具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catDog := &amp;CatDog&#123;&#125;</span><br><span class="line"><span class="comment">//声明一个Cat接口，将catDog指针类型赋值给cat</span></span><br><span class="line"><span class="keyword">var</span> car Cat</span><br><span class="line">cat = catDog</span><br><span class="line">cat.CatchMouse()</span><br></pre></td></tr></table></figure><h2 id="内嵌和组合"><a href="#内嵌和组合" class="headerlink" title="内嵌和组合"></a>内嵌和组合</h2><p>结构体内部可以内嵌结构体，也可有匿名字段</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="type">int</span>    </span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    d := &amp;Dog&#123;            </span><br><span class="line">        Feet: <span class="number">4</span>,            </span><br><span class="line">        Animal: &amp;Animal&#123;                     </span><br><span class="line">            name: <span class="string">&quot;狗蛋&quot;</span>,            </span><br><span class="line">        &#125;,    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;h2 id=&quot;Linux下go环境安装&quot;&gt;&lt;a href=&quot;#Linux下go环境安装&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="golang" scheme="https://zhaozhan.site/categories/golang/"/>
    
    
    <category term="golang" scheme="https://zhaozhan.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="https://zhaozhan.site/2024/02/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zhaozhan.site/2024/02/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-02-19T08:09:47.000Z</published>
    <updated>2024-02-19T08:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建方式"><a href="#搭建方式" class="headerlink" title="搭建方式"></a>搭建方式</h1><p>经过多种方式的尝试进行个人博客的搭建，最终选择以下方式：</p><ul><li>hexo框架</li><li>keep主题</li><li>Github pages 自动化部署</li><li>阿里云域名解析</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a class="link"   href="https://hexo.io/zh-cn/docs/" >hexo官方文档<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://keep-docs.xpoet.cn/basis/get-start/install-theme.html" >keep主题官方文档<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://juejin.cn/post/6943895271751286821" >Github Actions自动部署<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/529826545" >Github Pages自定义域名<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建方式&quot;&gt;&lt;a href=&quot;#搭建方式&quot; class=&quot;headerlink&quot; title=&quot;搭建方式&quot;&gt;&lt;/a&gt;搭建方式&lt;/h1&gt;&lt;p&gt;经过多种方式的尝试进行个人博客的搭建，最终选择以下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hexo框架&lt;/li&gt;
&lt;li&gt;keep</summary>
      
    
    
    
    
  </entry>
  
</feed>
